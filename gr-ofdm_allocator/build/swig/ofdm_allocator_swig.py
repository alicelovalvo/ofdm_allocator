# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ofdm_allocator_swig')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ofdm_allocator_swig')
    _ofdm_allocator_swig = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ofdm_allocator_swig', [dirname(__file__)])
        except ImportError:
            import _ofdm_allocator_swig
            return _ofdm_allocator_swig
        try:
            _mod = imp.load_module('_ofdm_allocator_swig', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ofdm_allocator_swig = swig_import_helper()
    del swig_import_helper
else:
    import _ofdm_allocator_swig
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
    """high_res_timer_now() -> gr::high_res_timer_type"""
    return _ofdm_allocator_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
    """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
    return _ofdm_allocator_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
    """high_res_timer_tps() -> gr::high_res_timer_type"""
    return _ofdm_allocator_swig.high_res_timer_tps()

def high_res_timer_epoch():
    """high_res_timer_epoch() -> gr::high_res_timer_type"""
    return _ofdm_allocator_swig.high_res_timer_epoch()
class vector_source_tagged(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, bool fixed_data=False, int fft_len=64, int max_len_data_subcarr=48, int max_len_pilot_subcarr=10, int max_vector_data_subcarr=4, int max_vector_pilot_subcarr=1, bool fixed_pilot=False, std::vector< int,std::allocator< int > > const & pilot, std::string const & length_tag_key, std::string const & length_tag_key_2, tags_vector_t tags) -> vector_source_tagged_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::vector_source_tagged.

        To avoid accidental use of raw pointers, ofdm_allocator::vector_source_tagged's constructor is in a private implementation class. ofdm_allocator::vector_source_tagged::make is the public interface for creating new instances.

        Params: (data, repeat, vlen, fixed_data, fft_len, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, pilot, length_tag_key, length_tag_key_2, tags)
        """
        return _ofdm_allocator_swig.vector_source_tagged_make(*args, **kwargs)

    make = staticmethod(make)

    def rewind(self):
        """
        rewind(vector_source_tagged self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_rewind(self)


    def set_data(self, *args, **kwargs):
        """
        set_data(vector_source_tagged self, std::vector< int,std::allocator< int > > const & data, tags_vector_t tags)



        Params: (data, tags)
        """
        return _ofdm_allocator_swig.vector_source_tagged_set_data(self, *args, **kwargs)


    def final_update(self):
        """
        final_update(vector_source_tagged self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_final_update(self)


    def set_random_vector_data(self):
        """
        set_random_vector_data(vector_source_tagged self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_set_random_vector_data(self)


    def set_random_vector_pilot(self):
        """
        set_random_vector_pilot(vector_source_tagged self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_set_random_vector_pilot(self)


    def set_repeat(self, repeat):
        """
        set_repeat(vector_source_tagged self, bool repeat)



        Params: (repeat)
        """
        return _ofdm_allocator_swig.vector_source_tagged_set_repeat(self, repeat)

    __swig_destroy__ = _ofdm_allocator_swig.delete_vector_source_tagged
    __del__ = lambda self: None
vector_source_tagged_swigregister = _ofdm_allocator_swig.vector_source_tagged_swigregister
vector_source_tagged_swigregister(vector_source_tagged)

def vector_source_tagged_make(*args, **kwargs):
    """
    vector_source_tagged_make(std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, bool fixed_data=False, int fft_len=64, int max_len_data_subcarr=48, int max_len_pilot_subcarr=10, int max_vector_data_subcarr=4, int max_vector_pilot_subcarr=1, bool fixed_pilot=False, std::vector< int,std::allocator< int > > const & pilot, std::string const & length_tag_key, std::string const & length_tag_key_2, tags_vector_t tags) -> vector_source_tagged_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::vector_source_tagged.

    To avoid accidental use of raw pointers, ofdm_allocator::vector_source_tagged's constructor is in a private implementation class. ofdm_allocator::vector_source_tagged::make is the public interface for creating new instances.

    Params: (data, repeat, vlen, fixed_data, fft_len, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, pilot, length_tag_key, length_tag_key_2, tags)
    """
    return _ofdm_allocator_swig.vector_source_tagged_make(*args, **kwargs)

class vector_source_tagged_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::vector_source_tagged)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::vector_source_tagged)> self) -> vector_source_tagged_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::vector_source_tagged)> self, vector_source_tagged p) -> vector_source_tagged_sptr
        """
        this = _ofdm_allocator_swig.new_vector_source_tagged_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(vector_source_tagged_sptr self) -> vector_source_tagged"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_vector_source_tagged_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(vector_source_tagged_sptr self, std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, bool fixed_data=False, int fft_len=64, int max_len_data_subcarr=48, int max_len_pilot_subcarr=10, int max_vector_data_subcarr=4, int max_vector_pilot_subcarr=1, bool fixed_pilot=False, std::vector< int,std::allocator< int > > const & pilot, std::string const & length_tag_key, std::string const & length_tag_key_2, tags_vector_t tags) -> vector_source_tagged_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::vector_source_tagged.

        To avoid accidental use of raw pointers, ofdm_allocator::vector_source_tagged's constructor is in a private implementation class. ofdm_allocator::vector_source_tagged::make is the public interface for creating new instances.

        Params: (data, repeat, vlen, fixed_data, fft_len, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, pilot, length_tag_key, length_tag_key_2, tags)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_make(self, *args, **kwargs)


    def rewind(self):
        """
        rewind(vector_source_tagged_sptr self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_rewind(self)


    def set_data(self, *args, **kwargs):
        """
        set_data(vector_source_tagged_sptr self, std::vector< int,std::allocator< int > > const & data, tags_vector_t tags)



        Params: (data, tags)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_data(self, *args, **kwargs)


    def final_update(self):
        """
        final_update(vector_source_tagged_sptr self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_final_update(self)


    def set_random_vector_data(self):
        """
        set_random_vector_data(vector_source_tagged_sptr self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_random_vector_data(self)


    def set_random_vector_pilot(self):
        """
        set_random_vector_pilot(vector_source_tagged_sptr self)



        Params: (NONE)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_random_vector_pilot(self)


    def set_repeat(self, repeat):
        """
        set_repeat(vector_source_tagged_sptr self, bool repeat)



        Params: (repeat)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_repeat(self, repeat)


    def history(self):
        """history(vector_source_tagged_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_tagged_sptr self, int which, int delay)
        declare_sample_delay(vector_source_tagged_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(vector_source_tagged_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(vector_source_tagged_sptr self) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(vector_source_tagged_sptr self) -> double"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_relative_rate(self)


    def start(self):
        """start(vector_source_tagged_sptr self) -> bool"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_start(self)


    def stop(self):
        """stop(vector_source_tagged_sptr self) -> bool"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(vector_source_tagged_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(vector_source_tagged_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(vector_source_tagged_sptr self) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(vector_source_tagged_sptr self, int m)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_tagged_sptr self)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_tagged_sptr self) -> bool"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(vector_source_tagged_sptr self, int m)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(vector_source_tagged_sptr self) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(vector_source_tagged_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_tagged_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_tagged_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(vector_source_tagged_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_tagged_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_tagged_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_tagged_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_tagged_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_tagged_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_tagged_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_tagged_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_tagged_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_tagged_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_tagged_sptr self) -> float"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(vector_source_tagged_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_tagged_sptr self)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(vector_source_tagged_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(vector_source_tagged_sptr self) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(vector_source_tagged_sptr self) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(vector_source_tagged_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(vector_source_tagged_sptr self) -> std::string"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_name(self)


    def symbol_name(self):
        """symbol_name(vector_source_tagged_sptr self) -> std::string"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(vector_source_tagged_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(vector_source_tagged_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(vector_source_tagged_sptr self) -> long"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(vector_source_tagged_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(vector_source_tagged_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(vector_source_tagged_sptr self) -> std::string"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(vector_source_tagged_sptr self, std::string name)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(vector_source_tagged_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(vector_source_tagged_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(vector_source_tagged_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(vector_source_tagged_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.vector_source_tagged_sptr_message_subscribers(self, which_port)

vector_source_tagged_sptr_swigregister = _ofdm_allocator_swig.vector_source_tagged_sptr_swigregister
vector_source_tagged_sptr_swigregister(vector_source_tagged_sptr)


vector_source_tagged_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_tagged = vector_source_tagged.make;

class allocator_subcarrier(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def len_tag_key(self):
        """
        len_tag_key(allocator_subcarrier self) -> std::string



        Params: (NONE)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_len_tag_key(self)


    def fft_len(self):
        """
        fft_len(allocator_subcarrier self) -> int const



        Params: (NONE)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_fft_len(self)


    def make(*args, **kwargs):
        """
        make(int fft_len, int vector_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, gr_vector_vector_complexf sync_words, std::string const & len_tag_key, bool const output_is_shifted=True) -> allocator_subcarrier_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::allocator_subcarrier.

        To avoid accidental use of raw pointers, ofdm_allocator::allocator_subcarrier's constructor is in a private implementation class. ofdm_allocator::allocator_subcarrier::make is the public interface for creating new instances.

        Params: (fft_len, vector_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_allocator_subcarrier
    __del__ = lambda self: None
allocator_subcarrier_swigregister = _ofdm_allocator_swig.allocator_subcarrier_swigregister
allocator_subcarrier_swigregister(allocator_subcarrier)

def allocator_subcarrier_make(*args, **kwargs):
    """
    allocator_subcarrier_make(int fft_len, int vector_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, gr_vector_vector_complexf sync_words, std::string const & len_tag_key, bool const output_is_shifted=True) -> allocator_subcarrier_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::allocator_subcarrier.

    To avoid accidental use of raw pointers, ofdm_allocator::allocator_subcarrier's constructor is in a private implementation class. ofdm_allocator::allocator_subcarrier::make is the public interface for creating new instances.

    Params: (fft_len, vector_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
    """
    return _ofdm_allocator_swig.allocator_subcarrier_make(*args, **kwargs)

class allocator_subcarrier_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::allocator_subcarrier)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::allocator_subcarrier)> self) -> allocator_subcarrier_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::allocator_subcarrier)> self, allocator_subcarrier p) -> allocator_subcarrier_sptr
        """
        this = _ofdm_allocator_swig.new_allocator_subcarrier_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(allocator_subcarrier_sptr self) -> allocator_subcarrier"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_allocator_subcarrier_sptr
    __del__ = lambda self: None

    def len_tag_key(self):
        """
        len_tag_key(allocator_subcarrier_sptr self) -> std::string



        Params: (NONE)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_len_tag_key(self)


    def fft_len(self):
        """
        fft_len(allocator_subcarrier_sptr self) -> int const



        Params: (NONE)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_fft_len(self)


    def make(self, *args, **kwargs):
        """
        make(allocator_subcarrier_sptr self, int fft_len, int vector_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, gr_vector_vector_complexf sync_words, std::string const & len_tag_key, bool const output_is_shifted=True) -> allocator_subcarrier_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::allocator_subcarrier.

        To avoid accidental use of raw pointers, ofdm_allocator::allocator_subcarrier's constructor is in a private implementation class. ofdm_allocator::allocator_subcarrier::make is the public interface for creating new instances.

        Params: (fft_len, vector_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_carriers, pilot_symbols, sync_words, len_tag_key, output_is_shifted)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_make(self, *args, **kwargs)


    def history(self):
        """history(allocator_subcarrier_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(allocator_subcarrier_sptr self, int which, int delay)
        declare_sample_delay(allocator_subcarrier_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(allocator_subcarrier_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(allocator_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(allocator_subcarrier_sptr self) -> double"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_relative_rate(self)


    def start(self):
        """start(allocator_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_start(self)


    def stop(self):
        """stop(allocator_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(allocator_subcarrier_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(allocator_subcarrier_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(allocator_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(allocator_subcarrier_sptr self, int m)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(allocator_subcarrier_sptr self)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(allocator_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(allocator_subcarrier_sptr self, int m)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(allocator_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(allocator_subcarrier_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(allocator_subcarrier_sptr self, long max_output_buffer)
        set_max_output_buffer(allocator_subcarrier_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(allocator_subcarrier_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(allocator_subcarrier_sptr self, long min_output_buffer)
        set_min_output_buffer(allocator_subcarrier_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(allocator_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(allocator_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full_avg(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(allocator_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full_var(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(allocator_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(allocator_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full_avg(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(allocator_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full_var(allocator_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(allocator_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(allocator_subcarrier_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(allocator_subcarrier_sptr self)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(allocator_subcarrier_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(allocator_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(allocator_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(allocator_subcarrier_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(allocator_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_name(self)


    def symbol_name(self):
        """symbol_name(allocator_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(allocator_subcarrier_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(allocator_subcarrier_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(allocator_subcarrier_sptr self) -> long"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(allocator_subcarrier_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(allocator_subcarrier_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(allocator_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(allocator_subcarrier_sptr self, std::string name)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(allocator_subcarrier_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(allocator_subcarrier_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(allocator_subcarrier_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(allocator_subcarrier_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.allocator_subcarrier_sptr_message_subscribers(self, which_port)

allocator_subcarrier_sptr_swigregister = _ofdm_allocator_swig.allocator_subcarrier_sptr_swigregister
allocator_subcarrier_sptr_swigregister(allocator_subcarrier_sptr)


allocator_subcarrier_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
allocator_subcarrier = allocator_subcarrier.make;

class serializer_subcarrier(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(*args, **kwargs):
        """
        make(int fft_len, int vector_len, bool fixed_pilot=True, bool fixed_data=True, int max_len_data_subcarr=48, int max_len_pilot_subcarr=4, int max_vector_data_subcarr=1, int max_vector_pilot_subcarr=1, std::string const & len_tag_key, std::string const & packet_len_tag_key, int symbols_skipped=0, std::string const & carr_offset_key, bool input_is_shifted=True) -> serializer_subcarrier_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::serializer_subcarrier.

        To avoid accidental use of raw pointers, ofdm_allocator::serializer_subcarrier's constructor is in a private implementation class. ofdm_allocator::serializer_subcarrier::make is the public interface for creating new instances.

        Params: (fft_len, vector_len, fixed_pilot, fixed_data, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
        """
        return _ofdm_allocator_swig.serializer_subcarrier_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_serializer_subcarrier
    __del__ = lambda self: None
serializer_subcarrier_swigregister = _ofdm_allocator_swig.serializer_subcarrier_swigregister
serializer_subcarrier_swigregister(serializer_subcarrier)

def serializer_subcarrier_make(*args, **kwargs):
    """
    serializer_subcarrier_make(int fft_len, int vector_len, bool fixed_pilot=True, bool fixed_data=True, int max_len_data_subcarr=48, int max_len_pilot_subcarr=4, int max_vector_data_subcarr=1, int max_vector_pilot_subcarr=1, std::string const & len_tag_key, std::string const & packet_len_tag_key, int symbols_skipped=0, std::string const & carr_offset_key, bool input_is_shifted=True) -> serializer_subcarrier_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::serializer_subcarrier.

    To avoid accidental use of raw pointers, ofdm_allocator::serializer_subcarrier's constructor is in a private implementation class. ofdm_allocator::serializer_subcarrier::make is the public interface for creating new instances.

    Params: (fft_len, vector_len, fixed_pilot, fixed_data, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
    """
    return _ofdm_allocator_swig.serializer_subcarrier_make(*args, **kwargs)

class serializer_subcarrier_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::serializer_subcarrier)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::serializer_subcarrier)> self) -> serializer_subcarrier_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::serializer_subcarrier)> self, serializer_subcarrier p) -> serializer_subcarrier_sptr
        """
        this = _ofdm_allocator_swig.new_serializer_subcarrier_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(serializer_subcarrier_sptr self) -> serializer_subcarrier"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_serializer_subcarrier_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(serializer_subcarrier_sptr self, int fft_len, int vector_len, bool fixed_pilot=True, bool fixed_data=True, int max_len_data_subcarr=48, int max_len_pilot_subcarr=4, int max_vector_data_subcarr=1, int max_vector_pilot_subcarr=1, std::string const & len_tag_key, std::string const & packet_len_tag_key, int symbols_skipped=0, std::string const & carr_offset_key, bool input_is_shifted=True) -> serializer_subcarrier_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::serializer_subcarrier.

        To avoid accidental use of raw pointers, ofdm_allocator::serializer_subcarrier's constructor is in a private implementation class. ofdm_allocator::serializer_subcarrier::make is the public interface for creating new instances.

        Params: (fft_len, vector_len, fixed_pilot, fixed_data, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, len_tag_key, packet_len_tag_key, symbols_skipped, carr_offset_key, input_is_shifted)
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_make(self, *args, **kwargs)


    def history(self):
        """history(serializer_subcarrier_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(serializer_subcarrier_sptr self, int which, int delay)
        declare_sample_delay(serializer_subcarrier_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(serializer_subcarrier_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(serializer_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(serializer_subcarrier_sptr self) -> double"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_relative_rate(self)


    def start(self):
        """start(serializer_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_start(self)


    def stop(self):
        """stop(serializer_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(serializer_subcarrier_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(serializer_subcarrier_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(serializer_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(serializer_subcarrier_sptr self, int m)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(serializer_subcarrier_sptr self)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(serializer_subcarrier_sptr self) -> bool"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(serializer_subcarrier_sptr self, int m)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(serializer_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(serializer_subcarrier_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(serializer_subcarrier_sptr self, long max_output_buffer)
        set_max_output_buffer(serializer_subcarrier_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(serializer_subcarrier_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(serializer_subcarrier_sptr self, long min_output_buffer)
        set_min_output_buffer(serializer_subcarrier_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(serializer_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(serializer_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full_avg(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(serializer_subcarrier_sptr self, int which) -> float
        pc_input_buffers_full_var(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(serializer_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(serializer_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full_avg(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(serializer_subcarrier_sptr self, int which) -> float
        pc_output_buffers_full_var(serializer_subcarrier_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(serializer_subcarrier_sptr self) -> float"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(serializer_subcarrier_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(serializer_subcarrier_sptr self)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(serializer_subcarrier_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(serializer_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(serializer_subcarrier_sptr self) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(serializer_subcarrier_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(serializer_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_name(self)


    def symbol_name(self):
        """symbol_name(serializer_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(serializer_subcarrier_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(serializer_subcarrier_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(serializer_subcarrier_sptr self) -> long"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(serializer_subcarrier_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(serializer_subcarrier_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(serializer_subcarrier_sptr self) -> std::string"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(serializer_subcarrier_sptr self, std::string name)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(serializer_subcarrier_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(serializer_subcarrier_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(serializer_subcarrier_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(serializer_subcarrier_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.serializer_subcarrier_sptr_message_subscribers(self, which_port)

serializer_subcarrier_sptr_swigregister = _ofdm_allocator_swig.serializer_subcarrier_sptr_swigregister
serializer_subcarrier_sptr_swigregister(serializer_subcarrier_sptr)


serializer_subcarrier_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
serializer_subcarrier = serializer_subcarrier.make;

class packet_header_default_alix(object):
    """<+description+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """
        __init__(gr::ofdm_allocator::packet_header_default_alix self, long header_len, std::string const & len_tag_key, std::string const & num_tag_key, int bits_per_byte=1) -> packet_header_default_alix



        Params: (header_len, len_tag_key, num_tag_key, bits_per_byte)
        """
        this = _ofdm_allocator_swig.new_packet_header_default_alix(*args, **kwargs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_default_alix
    __del__ = lambda self: None

    def base(self):
        """
        base(packet_header_default_alix self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_base(self)


    def formatter(self):
        """
        formatter(packet_header_default_alix self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_formatter(self)


    def set_header_num(self, header_num):
        """
        set_header_num(packet_header_default_alix self, unsigned int header_num)



        Params: (header_num)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_set_header_num(self, header_num)


    def header_len(self):
        """
        header_len(packet_header_default_alix self) -> long



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_header_len(self)


    def len_tag_key(self):
        """
        len_tag_key(packet_header_default_alix self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_len_tag_key(self)


    def num_tag_key(self):
        """
        num_tag_key(packet_header_default_alix self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_num_tag_key(self)


    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default_alix self, long packet_len, unsigned char * out, tags_vector_t tags) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_header_formatter(self, *args, **kwargs)


    def header_parser(self, header, header_length, tags):
        """
        header_parser(packet_header_default_alix self, unsigned char const * header, int header_length, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, header_length, tags)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_header_parser(self, header, header_length, tags)


    def make(*args, **kwargs):
        """
        make(long header_len, std::string const & len_tag_key, std::string const & num_tag_key, int bits_per_byte=1) -> packet_header_default_alix_sptr



        Params: (header_len, len_tag_key, num_tag_key, bits_per_byte)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_default_alix_swigregister = _ofdm_allocator_swig.packet_header_default_alix_swigregister
packet_header_default_alix_swigregister(packet_header_default_alix)

def packet_header_default_alix_make(*args, **kwargs):
    """
    packet_header_default_alix_make(long header_len, std::string const & len_tag_key, std::string const & num_tag_key, int bits_per_byte=1) -> packet_header_default_alix_sptr



    Params: (header_len, len_tag_key, num_tag_key, bits_per_byte)
    """
    return _ofdm_allocator_swig.packet_header_default_alix_make(*args, **kwargs)

class packet_header_gen(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(*args):
        """
        make(packet_header_default_alix_sptr header_formatter, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr
        make(long header_len, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::packet_header_gen.

        To avoid accidental use of raw pointers, ofdm_allocator::packet_header_gen's constructor is in a private implementation class. ofdm_allocator::packet_header_gen::make is the public interface for creating new instances.

        Params: (header_formatter, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, vector_len, len_tag_key)
        """
        return _ofdm_allocator_swig.packet_header_gen_make(*args)

    make = staticmethod(make)

    def set_header_formatter(self, header_formatter):
        """
        set_header_formatter(packet_header_gen self, packet_header_default_alix_sptr header_formatter)



        Params: (header_formatter)
        """
        return _ofdm_allocator_swig.packet_header_gen_set_header_formatter(self, header_formatter)

    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_gen
    __del__ = lambda self: None
packet_header_gen_swigregister = _ofdm_allocator_swig.packet_header_gen_swigregister
packet_header_gen_swigregister(packet_header_gen)

def packet_header_gen_make(*args):
    """
    make(packet_header_default_alix_sptr header_formatter, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr
    packet_header_gen_make(long header_len, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::packet_header_gen.

    To avoid accidental use of raw pointers, ofdm_allocator::packet_header_gen's constructor is in a private implementation class. ofdm_allocator::packet_header_gen::make is the public interface for creating new instances.

    Params: (header_formatter, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, vector_len, len_tag_key)
    """
    return _ofdm_allocator_swig.packet_header_gen_make(*args)

class packet_header_gen_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::packet_header_gen)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_gen)> self) -> packet_header_gen_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_gen)> self, packet_header_gen p) -> packet_header_gen_sptr
        """
        this = _ofdm_allocator_swig.new_packet_header_gen_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(packet_header_gen_sptr self) -> packet_header_gen"""
        return _ofdm_allocator_swig.packet_header_gen_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_gen_sptr
    __del__ = lambda self: None

    def make(self, *args):
        """
        make(packet_header_gen_sptr self, packet_header_default_alix_sptr header_formatter, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr
        make(packet_header_gen_sptr self, long header_len, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, bool fixed_pilot, int vector_len, std::string const & len_tag_key) -> packet_header_gen_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::packet_header_gen.

        To avoid accidental use of raw pointers, ofdm_allocator::packet_header_gen's constructor is in a private implementation class. ofdm_allocator::packet_header_gen::make is the public interface for creating new instances.

        Params: (header_formatter, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, fixed_pilot, vector_len, len_tag_key)
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_make(self, *args)


    def set_header_formatter(self, header_formatter):
        """
        set_header_formatter(packet_header_gen_sptr self, packet_header_default_alix_sptr header_formatter)



        Params: (header_formatter)
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_header_formatter(self, header_formatter)


    def history(self):
        """history(packet_header_gen_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(packet_header_gen_sptr self, int which, int delay)
        declare_sample_delay(packet_header_gen_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(packet_header_gen_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(packet_header_gen_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(packet_header_gen_sptr self) -> double"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_relative_rate(self)


    def start(self):
        """start(packet_header_gen_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_start(self)


    def stop(self):
        """stop(packet_header_gen_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(packet_header_gen_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(packet_header_gen_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(packet_header_gen_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(packet_header_gen_sptr self, int m)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(packet_header_gen_sptr self)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(packet_header_gen_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(packet_header_gen_sptr self, int m)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(packet_header_gen_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(packet_header_gen_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(packet_header_gen_sptr self, long max_output_buffer)
        set_max_output_buffer(packet_header_gen_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(packet_header_gen_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(packet_header_gen_sptr self, long min_output_buffer)
        set_min_output_buffer(packet_header_gen_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(packet_header_gen_sptr self, int which) -> float
        pc_input_buffers_full(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(packet_header_gen_sptr self, int which) -> float
        pc_input_buffers_full_avg(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(packet_header_gen_sptr self, int which) -> float
        pc_input_buffers_full_var(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(packet_header_gen_sptr self, int which) -> float
        pc_output_buffers_full(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(packet_header_gen_sptr self, int which) -> float
        pc_output_buffers_full_avg(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(packet_header_gen_sptr self, int which) -> float
        pc_output_buffers_full_var(packet_header_gen_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(packet_header_gen_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(packet_header_gen_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(packet_header_gen_sptr self)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(packet_header_gen_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(packet_header_gen_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(packet_header_gen_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(packet_header_gen_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(packet_header_gen_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_name(self)


    def symbol_name(self):
        """symbol_name(packet_header_gen_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(packet_header_gen_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(packet_header_gen_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(packet_header_gen_sptr self) -> long"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(packet_header_gen_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(packet_header_gen_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(packet_header_gen_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(packet_header_gen_sptr self, std::string name)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(packet_header_gen_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.packet_header_gen_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(packet_header_gen_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(packet_header_gen_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(packet_header_gen_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_gen_sptr_message_subscribers(self, which_port)

packet_header_gen_sptr_swigregister = _ofdm_allocator_swig.packet_header_gen_sptr_swigregister
packet_header_gen_sptr_swigregister(packet_header_gen_sptr)


packet_header_gen_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
packet_header_gen = packet_header_gen.make;

class packet_header_ofdm_alix(packet_header_default_alix):
    """<+description+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header):
        """
        __init__(gr::ofdm_allocator::packet_header_ofdm_alix self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, int n_syms, std::string const & len_tag_key, std::string const & frame_len_tag_key, std::string const & num_tag_key, int bits_per_header_sym, int bits_per_payload_sym, bool scramble_header) -> packet_header_ofdm_alix



        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header)
        """
        this = _ofdm_allocator_swig.new_packet_header_ofdm_alix(occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_ofdm_alix
    __del__ = lambda self: None

    def make(*args, **kwargs):
        """
        make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, int n_syms, std::string const & len_tag_key, std::string const & frame_len_tag_key, std::string const & num_tag_key, int bits_per_header_sym=1, int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_alix_sptr



        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_ofdm_alix_swigregister = _ofdm_allocator_swig.packet_header_ofdm_alix_swigregister
packet_header_ofdm_alix_swigregister(packet_header_ofdm_alix)

def packet_header_ofdm_alix_make(*args, **kwargs):
    """
    packet_header_ofdm_alix_make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, int n_syms, std::string const & len_tag_key, std::string const & frame_len_tag_key, std::string const & num_tag_key, int bits_per_header_sym=1, int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_alix_sptr



    Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header)
    """
    return _ofdm_allocator_swig.packet_header_ofdm_alix_make(*args, **kwargs)

class ofdm_equalizer_base_alix(object):
    """<+description+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_base_alix
    __del__ = lambda self: None

    def reset(self, pilot_carriers):
        """
        reset(ofdm_equalizer_base_alix self, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers)

        Reset the channel information state knowledge.

        Params: (pilot_carriers)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_reset(self, pilot_carriers)


    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base_alix self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & occupied_carriers, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, tags_vector_t tags)

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, occupied_carriers, pilot_carriers, pilot_symbols, tags)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_equalize(self, *args, **kwargs)


    def get_channel_state(self, taps):
        """
        get_channel_state(ofdm_equalizer_base_alix self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_get_channel_state(self, taps)


    def fft_len(self):
        """
        fft_len(ofdm_equalizer_base_alix self) -> int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_fft_len(self)


    def base(self):
        """
        base(ofdm_equalizer_base_alix self) -> ofdm_equalizer_base_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_base(self)

ofdm_equalizer_base_alix_swigregister = _ofdm_allocator_swig.ofdm_equalizer_base_alix_swigregister
ofdm_equalizer_base_alix_swigregister(ofdm_equalizer_base_alix)

class ofdm_equalizer_1d_pilots_alix(ofdm_equalizer_base_alix):
    """Proxy of C++ gr::ofdm_allocator::ofdm_equalizer_1d_pilots_alix class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_1d_pilots_alix
    __del__ = lambda self: None
ofdm_equalizer_1d_pilots_alix_swigregister = _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_swigregister
ofdm_equalizer_1d_pilots_alix_swigregister(ofdm_equalizer_1d_pilots_alix)

class frame_equalizer_alix(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(*args, **kwargs):
        """
        make(ofdm_equalizer_base_alix_sptr equalizer, int vector_len, int cp_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, gr_vector_vector_complexf pilot_symbols, std::string const & tsb_key, bool propagate_channel_state=False, int fixed_frame_len=0, bool input_is_shifted=True) -> frame_equalizer_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::frame_equalizer_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::frame_equalizer_alix's constructor is in a private implementation class. ofdm_allocator::frame_equalizer_alix::make is the public interface for creating new instances.

        Params: (equalizer, vector_len, cp_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_symbols, tsb_key, propagate_channel_state, fixed_frame_len, input_is_shifted)
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_frame_equalizer_alix
    __del__ = lambda self: None
frame_equalizer_alix_swigregister = _ofdm_allocator_swig.frame_equalizer_alix_swigregister
frame_equalizer_alix_swigregister(frame_equalizer_alix)

def frame_equalizer_alix_make(*args, **kwargs):
    """
    frame_equalizer_alix_make(ofdm_equalizer_base_alix_sptr equalizer, int vector_len, int cp_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, gr_vector_vector_complexf pilot_symbols, std::string const & tsb_key, bool propagate_channel_state=False, int fixed_frame_len=0, bool input_is_shifted=True) -> frame_equalizer_alix_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::frame_equalizer_alix.

    To avoid accidental use of raw pointers, ofdm_allocator::frame_equalizer_alix's constructor is in a private implementation class. ofdm_allocator::frame_equalizer_alix::make is the public interface for creating new instances.

    Params: (equalizer, vector_len, cp_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_symbols, tsb_key, propagate_channel_state, fixed_frame_len, input_is_shifted)
    """
    return _ofdm_allocator_swig.frame_equalizer_alix_make(*args, **kwargs)

class frame_equalizer_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::frame_equalizer_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::frame_equalizer_alix)> self) -> frame_equalizer_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::frame_equalizer_alix)> self, frame_equalizer_alix p) -> frame_equalizer_alix_sptr
        """
        this = _ofdm_allocator_swig.new_frame_equalizer_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(frame_equalizer_alix_sptr self) -> frame_equalizer_alix"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_frame_equalizer_alix_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(frame_equalizer_alix_sptr self, ofdm_equalizer_base_alix_sptr equalizer, int vector_len, int cp_len, bool fixed_data, bool fixed_pilot, int max_len_data_subcarr, int max_len_pilot_subcarr, int max_vector_data_subcarr, int max_vector_pilot_subcarr, gr_vector_vector_complexf pilot_symbols, std::string const & tsb_key, bool propagate_channel_state=False, int fixed_frame_len=0, bool input_is_shifted=True) -> frame_equalizer_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::frame_equalizer_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::frame_equalizer_alix's constructor is in a private implementation class. ofdm_allocator::frame_equalizer_alix::make is the public interface for creating new instances.

        Params: (equalizer, vector_len, cp_len, fixed_data, fixed_pilot, max_len_data_subcarr, max_len_pilot_subcarr, max_vector_data_subcarr, max_vector_pilot_subcarr, pilot_symbols, tsb_key, propagate_channel_state, fixed_frame_len, input_is_shifted)
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_make(self, *args, **kwargs)


    def history(self):
        """history(frame_equalizer_alix_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(frame_equalizer_alix_sptr self, int which, int delay)
        declare_sample_delay(frame_equalizer_alix_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(frame_equalizer_alix_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(frame_equalizer_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(frame_equalizer_alix_sptr self) -> double"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_relative_rate(self)


    def start(self):
        """start(frame_equalizer_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_start(self)


    def stop(self):
        """stop(frame_equalizer_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(frame_equalizer_alix_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(frame_equalizer_alix_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(frame_equalizer_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(frame_equalizer_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(frame_equalizer_alix_sptr self)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(frame_equalizer_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(frame_equalizer_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(frame_equalizer_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(frame_equalizer_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(frame_equalizer_alix_sptr self, long max_output_buffer)
        set_max_output_buffer(frame_equalizer_alix_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(frame_equalizer_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(frame_equalizer_alix_sptr self, long min_output_buffer)
        set_min_output_buffer(frame_equalizer_alix_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(frame_equalizer_alix_sptr self, int which) -> float
        pc_input_buffers_full(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(frame_equalizer_alix_sptr self, int which) -> float
        pc_input_buffers_full_avg(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(frame_equalizer_alix_sptr self, int which) -> float
        pc_input_buffers_full_var(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(frame_equalizer_alix_sptr self, int which) -> float
        pc_output_buffers_full(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(frame_equalizer_alix_sptr self, int which) -> float
        pc_output_buffers_full_avg(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(frame_equalizer_alix_sptr self, int which) -> float
        pc_output_buffers_full_var(frame_equalizer_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(frame_equalizer_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(frame_equalizer_alix_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(frame_equalizer_alix_sptr self)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(frame_equalizer_alix_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(frame_equalizer_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(frame_equalizer_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(frame_equalizer_alix_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(frame_equalizer_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_name(self)


    def symbol_name(self):
        """symbol_name(frame_equalizer_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(frame_equalizer_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(frame_equalizer_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(frame_equalizer_alix_sptr self) -> long"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(frame_equalizer_alix_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(frame_equalizer_alix_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(frame_equalizer_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(frame_equalizer_alix_sptr self, std::string name)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(frame_equalizer_alix_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(frame_equalizer_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(frame_equalizer_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(frame_equalizer_alix_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.frame_equalizer_alix_sptr_message_subscribers(self, which_port)

frame_equalizer_alix_sptr_swigregister = _ofdm_allocator_swig.frame_equalizer_alix_sptr_swigregister
frame_equalizer_alix_sptr_swigregister(frame_equalizer_alix_sptr)


frame_equalizer_alix_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
frame_equalizer_alix = frame_equalizer_alix.make;

class ofdm_equalizer_simpledfe_alix(ofdm_equalizer_1d_pilots_alix):
    """<+description+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        """
        __init__(gr::ofdm_allocator::ofdm_equalizer_simpledfe_alix self, int fft_len, constellation_alix_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, int symbols_skipped=0, float alpha=0.1, bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_alix



        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        this = _ofdm_allocator_swig.new_ofdm_equalizer_simpledfe_alix(*args, **kwargs)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_simpledfe_alix
    __del__ = lambda self: None

    def make(*args, **kwargs):
        """
        make(int fft_len, constellation_alix_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, int symbols_skipped=0, float alpha=0.1, bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_alix_sptr



        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_make(*args, **kwargs)

    make = staticmethod(make)
ofdm_equalizer_simpledfe_alix_swigregister = _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_swigregister
ofdm_equalizer_simpledfe_alix_swigregister(ofdm_equalizer_simpledfe_alix)

def ofdm_equalizer_simpledfe_alix_make(*args, **kwargs):
    """
    ofdm_equalizer_simpledfe_alix_make(int fft_len, constellation_alix_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, int symbols_skipped=0, float alpha=0.1, bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_alix_sptr



    Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
    """
    return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_make(*args, **kwargs)

class packet_header_default_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::packet_header_default_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_default_alix)> self) -> packet_header_default_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_default_alix)> self, packet_header_default_alix p) -> packet_header_default_alix_sptr
        """
        this = _ofdm_allocator_swig.new_packet_header_default_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(packet_header_default_alix_sptr self) -> packet_header_default_alix"""
        return _ofdm_allocator_swig.packet_header_default_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_default_alix_sptr
    __del__ = lambda self: None

    def base(self):
        """
        base(packet_header_default_alix_sptr self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_base(self)


    def formatter(self):
        """
        formatter(packet_header_default_alix_sptr self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_formatter(self)


    def set_header_num(self, header_num):
        """
        set_header_num(packet_header_default_alix_sptr self, unsigned int header_num)



        Params: (header_num)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_set_header_num(self, header_num)


    def header_len(self):
        """
        header_len(packet_header_default_alix_sptr self) -> long



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_header_len(self)


    def len_tag_key(self):
        """
        len_tag_key(packet_header_default_alix_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_len_tag_key(self)


    def num_tag_key(self):
        """
        num_tag_key(packet_header_default_alix_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_num_tag_key(self)


    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default_alix_sptr self, long packet_len, unsigned char * out, tags_vector_t tags) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_header_formatter(self, *args, **kwargs)


    def header_parser(self, header, header_length, tags):
        """
        header_parser(packet_header_default_alix_sptr self, unsigned char const * header, int header_length, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, header_length, tags)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_header_parser(self, header, header_length, tags)


    def make(self, *args, **kwargs):
        """
        make(packet_header_default_alix_sptr self, long header_len, std::string const & len_tag_key, std::string const & num_tag_key, int bits_per_byte=1) -> packet_header_default_alix_sptr



        Params: (header_len, len_tag_key, num_tag_key, bits_per_byte)
        """
        return _ofdm_allocator_swig.packet_header_default_alix_sptr_make(self, *args, **kwargs)

packet_header_default_alix_sptr_swigregister = _ofdm_allocator_swig.packet_header_default_alix_sptr_swigregister
packet_header_default_alix_sptr_swigregister(packet_header_default_alix_sptr)


packet_header_default_alix_sptr.__repr__ = lambda self: "<packet_header_default_alix>"
packet_header_default_alix = packet_header_default_alix .make;

class packet_header_ofdm_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::packet_header_ofdm_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_ofdm_alix)> self) -> packet_header_ofdm_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_ofdm_alix)> self, packet_header_ofdm_alix p) -> packet_header_ofdm_alix_sptr
        """
        this = _ofdm_allocator_swig.new_packet_header_ofdm_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(packet_header_ofdm_alix_sptr self) -> packet_header_ofdm_alix"""
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_ofdm_alix_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(packet_header_ofdm_alix_sptr self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, int n_syms, std::string const & len_tag_key, std::string const & frame_len_tag_key, std::string const & num_tag_key, int bits_per_header_sym=1, int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_alix_sptr



        Params: (occupied_carriers, n_syms, len_tag_key, frame_len_tag_key, num_tag_key, bits_per_header_sym, bits_per_payload_sym, scramble_header)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_make(self, *args, **kwargs)


    def base(self):
        """
        base(packet_header_ofdm_alix_sptr self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_base(self)


    def formatter(self):
        """
        formatter(packet_header_ofdm_alix_sptr self) -> packet_header_default_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_formatter(self)


    def set_header_num(self, header_num):
        """
        set_header_num(packet_header_ofdm_alix_sptr self, unsigned int header_num)



        Params: (header_num)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_set_header_num(self, header_num)


    def header_len(self):
        """
        header_len(packet_header_ofdm_alix_sptr self) -> long



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_header_len(self)


    def len_tag_key(self):
        """
        len_tag_key(packet_header_ofdm_alix_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_len_tag_key(self)


    def num_tag_key(self):
        """
        num_tag_key(packet_header_ofdm_alix_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_num_tag_key(self)


    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_ofdm_alix_sptr self, long packet_len, unsigned char * out, tags_vector_t tags) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.

        Params: (packet_len, out, tags)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_header_formatter(self, *args, **kwargs)


    def header_parser(self, header, header_length, tags):
        """
        header_parser(packet_header_ofdm_alix_sptr self, unsigned char const * header, int header_length, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .

        Params: (header, header_length, tags)
        """
        return _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_header_parser(self, header, header_length, tags)

packet_header_ofdm_alix_sptr_swigregister = _ofdm_allocator_swig.packet_header_ofdm_alix_sptr_swigregister
packet_header_ofdm_alix_sptr_swigregister(packet_header_ofdm_alix_sptr)


packet_header_ofdm_alix_sptr.__repr__ = lambda self: "<packet_header_ofdm_alix>"
packet_header_ofdm_alix = packet_header_ofdm_alix .make;

class ofdm_equalizer_base_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_base_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_base_alix)> self) -> ofdm_equalizer_base_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_base_alix)> self, ofdm_equalizer_base_alix p) -> ofdm_equalizer_base_alix_sptr
        """
        this = _ofdm_allocator_swig.new_ofdm_equalizer_base_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(ofdm_equalizer_base_alix_sptr self) -> ofdm_equalizer_base_alix"""
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_base_alix_sptr
    __del__ = lambda self: None

    def reset(self, pilot_carriers):
        """
        reset(ofdm_equalizer_base_alix_sptr self, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers)

        Reset the channel information state knowledge.

        Params: (pilot_carriers)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_reset(self, pilot_carriers)


    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base_alix_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & occupied_carriers, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, tags_vector_t tags)

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, occupied_carriers, pilot_carriers, pilot_symbols, tags)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_equalize(self, *args, **kwargs)


    def get_channel_state(self, taps):
        """
        get_channel_state(ofdm_equalizer_base_alix_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_get_channel_state(self, taps)


    def fft_len(self):
        """
        fft_len(ofdm_equalizer_base_alix_sptr self) -> int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_fft_len(self)


    def base(self):
        """
        base(ofdm_equalizer_base_alix_sptr self) -> ofdm_equalizer_base_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_base(self)

ofdm_equalizer_base_alix_sptr_swigregister = _ofdm_allocator_swig.ofdm_equalizer_base_alix_sptr_swigregister
ofdm_equalizer_base_alix_sptr_swigregister(ofdm_equalizer_base_alix_sptr)

class ofdm_equalizer_1d_pilots_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_1d_pilots_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_1d_pilots_alix)> self) -> ofdm_equalizer_1d_pilots_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_1d_pilots_alix)> self, ofdm_equalizer_1d_pilots_alix p) -> ofdm_equalizer_1d_pilots_alix_sptr
        """
        this = _ofdm_allocator_swig.new_ofdm_equalizer_1d_pilots_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(ofdm_equalizer_1d_pilots_alix_sptr self) -> ofdm_equalizer_1d_pilots_alix"""
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_1d_pilots_alix_sptr
    __del__ = lambda self: None

    def reset(self, pilot_carriers):
        """
        reset(ofdm_equalizer_1d_pilots_alix_sptr self, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers)

        Reset the channel information state knowledge.

        Params: (pilot_carriers)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_reset(self, pilot_carriers)


    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_1d_pilots_alix_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & occupied_carriers, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, tags_vector_t tags)

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, occupied_carriers, pilot_carriers, pilot_symbols, tags)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_equalize(self, *args, **kwargs)


    def get_channel_state(self, taps):
        """
        get_channel_state(ofdm_equalizer_1d_pilots_alix_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_get_channel_state(self, taps)


    def fft_len(self):
        """
        fft_len(ofdm_equalizer_1d_pilots_alix_sptr self) -> int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_fft_len(self)


    def base(self):
        """
        base(ofdm_equalizer_1d_pilots_alix_sptr self) -> ofdm_equalizer_base_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_base(self)

ofdm_equalizer_1d_pilots_alix_sptr_swigregister = _ofdm_allocator_swig.ofdm_equalizer_1d_pilots_alix_sptr_swigregister
ofdm_equalizer_1d_pilots_alix_sptr_swigregister(ofdm_equalizer_1d_pilots_alix_sptr)


ofdm_equalizer_1d_pilots_alix_sptr.__repr__ = lambda self: "<OFDM equalizer 1D base class>"

class ofdm_equalizer_simpledfe_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_simpledfe_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_simpledfe_alix)> self) -> ofdm_equalizer_simpledfe_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::ofdm_equalizer_simpledfe_alix)> self, ofdm_equalizer_simpledfe_alix p) -> ofdm_equalizer_simpledfe_alix_sptr
        """
        this = _ofdm_allocator_swig.new_ofdm_equalizer_simpledfe_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(ofdm_equalizer_simpledfe_alix_sptr self) -> ofdm_equalizer_simpledfe_alix"""
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_ofdm_equalizer_simpledfe_alix_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(ofdm_equalizer_simpledfe_alix_sptr self, int fft_len, constellation_alix_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, int symbols_skipped=0, float alpha=0.1, bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_alix_sptr



        Params: (fft_len, constellation, occupied_carriers, pilot_carriers, pilot_symbols, symbols_skipped, alpha, input_is_shifted)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_make(self, *args, **kwargs)


    def reset(self, pilot_carriers):
        """
        reset(ofdm_equalizer_simpledfe_alix_sptr self, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers)

        Reset the channel information state knowledge.

        Params: (pilot_carriers)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_reset(self, pilot_carriers)


    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_simpledfe_alix_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & occupied_carriers, std::vector< std::vector< bool,std::allocator< bool > >,std::allocator< std::vector< bool,std::allocator< bool > > > > const & pilot_carriers, gr_vector_vector_complexf pilot_symbols, tags_vector_t tags)

        Run the actual equalization.

        Params: (frame, n_sym, initial_taps, occupied_carriers, pilot_carriers, pilot_symbols, tags)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_equalize(self, *args, **kwargs)


    def get_channel_state(self, taps):
        """
        get_channel_state(ofdm_equalizer_simpledfe_alix_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.

        Params: (taps)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_get_channel_state(self, taps)


    def fft_len(self):
        """
        fft_len(ofdm_equalizer_simpledfe_alix_sptr self) -> int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_fft_len(self)


    def base(self):
        """
        base(ofdm_equalizer_simpledfe_alix_sptr self) -> ofdm_equalizer_base_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_base(self)

ofdm_equalizer_simpledfe_alix_sptr_swigregister = _ofdm_allocator_swig.ofdm_equalizer_simpledfe_alix_sptr_swigregister
ofdm_equalizer_simpledfe_alix_sptr_swigregister(ofdm_equalizer_simpledfe_alix_sptr)


ofdm_equalizer_simpledfe_alix_sptr.__repr__ = lambda self: "<ofdm_equalizer_simpledfe_alix>"
ofdm_equalizer_simpledfe_alix = ofdm_equalizer_simpledfe_alix .make;

class constellation_alix(object):
    """
    An abstracted constellation object.

    The constellation objects hold the necessary information to pass around constellation information for modulators and demodulators. These objects contain the mapping between the bits and the constellation points used to represent them as well as methods for slicing the symbol space. Various implementations are possible for efficiency and ease of use.

    Standard constellations (BPSK, QPSK, QAM, etc) can be inherited from this class and overloaded to perform optimized slicing and constellation mappings.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_alix
    __del__ = lambda self: None

    def map_to_points(self, value, points):
        """
        map_to_points(constellation_alix self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_alix_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_alix self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_alix_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_alix self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_alix self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_alix self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_alix_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_alix self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_alix_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_alix self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_alix_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_alix self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_alix_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_alix self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_points(self)


    def s_points(self):
        """
        s_points(constellation_alix self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_s_points(self)


    def v_points(self):
        """
        v_points(constellation_alix self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_alix self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_alix self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_alix_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_alix self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_alix self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_alix self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_alix self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_alix self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_arity(self)


    def base(self):
        """
        base(constellation_alix self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_alix self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_alix self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_alix_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_alix self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_alix_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_alix self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_alix_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_alix self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_alix self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_alix self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_soft_decision_maker(self, sample)

constellation_alix_swigregister = _ofdm_allocator_swig.constellation_alix_swigregister
constellation_alix_swigregister(constellation_alix)

class constellation_calcdist(constellation_alix):
    """
    Calculate Euclidian distance for any constellation.

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(constell, pre_diff_code, rotational_symmetry, dimensionality):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
        """
        return _ofdm_allocator_swig.constellation_calcdist_make(constell, pre_diff_code, rotational_symmetry, dimensionality)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_calcdist
    __del__ = lambda self: None
constellation_calcdist_swigregister = _ofdm_allocator_swig.constellation_calcdist_swigregister
constellation_calcdist_swigregister(constellation_calcdist)

def constellation_calcdist_make(constell, pre_diff_code, rotational_symmetry, dimensionality):
    """
    constellation_calcdist_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

    Make a general constellation object that calculates the Euclidean distance for hard decisions.

    Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
    """
    return _ofdm_allocator_swig.constellation_calcdist_make(constell, pre_diff_code, rotational_symmetry, dimensionality)

class constellation_sector(constellation_alix):
    """
    Sectorized digital constellation.

    constellation_sector

    Constellation space is divided into sectors. Each sector is associated with the nearest constellation point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_sector
    __del__ = lambda self: None
constellation_sector_swigregister = _ofdm_allocator_swig.constellation_sector_swigregister
constellation_sector_swigregister(constellation_sector)

class constellation_rect(constellation_sector):
    """
    Rectangular digital constellation

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    Works well for square QAM.

    Works for any generic constellation provided sectors are not too large.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Make a rectangular constellation object.

        Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
        """
        return _ofdm_allocator_swig.constellation_rect_make(constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_rect
    __del__ = lambda self: None
constellation_rect_swigregister = _ofdm_allocator_swig.constellation_rect_swigregister
constellation_rect_swigregister(constellation_rect)

def constellation_rect_make(constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors):
    """
    constellation_rect_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

    Make a rectangular constellation object.

    Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
    """
    return _ofdm_allocator_swig.constellation_rect_make(constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)

class constellation_expl_rect(constellation_rect):
    """
    Rectangular digital constellation.

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values):
        """
        make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr



        Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_make(constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_expl_rect
    __del__ = lambda self: None
constellation_expl_rect_swigregister = _ofdm_allocator_swig.constellation_expl_rect_swigregister
constellation_expl_rect_swigregister(constellation_expl_rect)

def constellation_expl_rect_make(constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values):
    """
    constellation_expl_rect_make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr



    Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
    """
    return _ofdm_allocator_swig.constellation_expl_rect_make(constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)

class constellation_psk(constellation_sector):
    """
    constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(constell, pre_diff_code, n_sectors):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int n_sectors) -> constellation_psk_sptr



        Params: (constell, pre_diff_code, n_sectors)
        """
        return _ofdm_allocator_swig.constellation_psk_make(constell, pre_diff_code, n_sectors)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_psk
    __del__ = lambda self: None
constellation_psk_swigregister = _ofdm_allocator_swig.constellation_psk_swigregister
constellation_psk_swigregister(constellation_psk)

def constellation_psk_make(constell, pre_diff_code, n_sectors):
    """
    constellation_psk_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int n_sectors) -> constellation_psk_sptr



    Params: (constell, pre_diff_code, n_sectors)
    """
    return _ofdm_allocator_swig.constellation_psk_make(constell, pre_diff_code, n_sectors)

class constellation_bpsk(constellation_alix):
    """Digital constellation for BPSK ."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_bpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_bpsk
    __del__ = lambda self: None
constellation_bpsk_swigregister = _ofdm_allocator_swig.constellation_bpsk_swigregister
constellation_bpsk_swigregister(constellation_bpsk)

def constellation_bpsk_make():
    """
    constellation_bpsk_make() -> constellation_bpsk_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_bpsk_make()

class constellation_qpsk(constellation_alix):
    """Digital constellation for QPSK."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_qpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_qpsk
    __del__ = lambda self: None
constellation_qpsk_swigregister = _ofdm_allocator_swig.constellation_qpsk_swigregister
constellation_qpsk_swigregister(constellation_qpsk)

def constellation_qpsk_make():
    """
    constellation_qpsk_make() -> constellation_qpsk_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_qpsk_make()

class constellation_dqpsk(constellation_alix):
    """Digital constellation for DQPSK."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_dqpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_dqpsk
    __del__ = lambda self: None
constellation_dqpsk_swigregister = _ofdm_allocator_swig.constellation_dqpsk_swigregister
constellation_dqpsk_swigregister(constellation_dqpsk)

def constellation_dqpsk_make():
    """
    constellation_dqpsk_make() -> constellation_dqpsk_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_dqpsk_make()

class constellation_8psk(constellation_alix):
    """Digital constellation for 8PSK."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_8psk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_8psk
    __del__ = lambda self: None
constellation_8psk_swigregister = _ofdm_allocator_swig.constellation_8psk_swigregister
constellation_8psk_swigregister(constellation_8psk)

def constellation_8psk_make():
    """
    constellation_8psk_make() -> constellation_8psk_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_8psk_make()

class constellation_8psk_natural(constellation_alix):
    """Digital constellation for natually mapped 8PSK."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_8psk_natural_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_8psk_natural
    __del__ = lambda self: None
constellation_8psk_natural_swigregister = _ofdm_allocator_swig.constellation_8psk_natural_swigregister
constellation_8psk_natural_swigregister(constellation_8psk_natural)

def constellation_8psk_natural_make():
    """
    constellation_8psk_natural_make() -> constellation_8psk_natural_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_8psk_natural_make()

class constellation_16qam(constellation_alix):
    """Digital constellation for 16qam."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make():
        """
        make() -> constellation_16qam_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_make()

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_16qam
    __del__ = lambda self: None
constellation_16qam_swigregister = _ofdm_allocator_swig.constellation_16qam_swigregister
constellation_16qam_swigregister(constellation_16qam)

def constellation_16qam_make():
    """
    constellation_16qam_make() -> constellation_16qam_sptr



    Params: (NONE)
    """
    return _ofdm_allocator_swig.constellation_16qam_make()

TRELLIS_EUCLIDEAN = _ofdm_allocator_swig.TRELLIS_EUCLIDEAN
TRELLIS_HARD_SYMBOL = _ofdm_allocator_swig.TRELLIS_HARD_SYMBOL
TRELLIS_HARD_BIT = _ofdm_allocator_swig.TRELLIS_HARD_BIT
class constellation_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_alix)> self) -> constellation_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_alix)> self, constellation_alix p) -> constellation_alix_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_alix_sptr self) -> constellation_alix"""
        return _ofdm_allocator_swig.constellation_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_alix_sptr
    __del__ = lambda self: None

    def map_to_points(self, value, points):
        """
        map_to_points(constellation_alix_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_alix_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_alix_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_alix_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_alix_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_alix_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_alix_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_alix_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_alix_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_alix_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_alix_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_alix_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_alix_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_alix_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_alix_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_alix_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_alix_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_alix_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_arity(self)


    def base(self):
        """
        base(constellation_alix_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_alix_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_alix_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_alix_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_alix_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_alix_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_alix_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_alix_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_alix_sptr_soft_decision_maker(self, sample)

constellation_alix_sptr_swigregister = _ofdm_allocator_swig.constellation_alix_sptr_swigregister
constellation_alix_sptr_swigregister(constellation_alix_sptr)

class constellation_calcdist_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_calcdist)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_calcdist)> self) -> constellation_calcdist_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_calcdist)> self, constellation_calcdist p) -> constellation_calcdist_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_calcdist_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_calcdist_sptr self) -> constellation_calcdist"""
        return _ofdm_allocator_swig.constellation_calcdist_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_calcdist_sptr
    __del__ = lambda self: None

    def make(self, constell, pre_diff_code, rotational_symmetry, dimensionality):
        """
        make(constellation_calcdist_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Params: (constell, pre_diff_code, rotational_symmetry, dimensionality)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_make(self, constell, pre_diff_code, rotational_symmetry, dimensionality)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_calcdist_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_calcdist_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_calcdist_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_calcdist_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_calcdist_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_calcdist_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_calcdist_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_calcdist_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_calcdist_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_calcdist_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_calcdist_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_calcdist_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_calcdist_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_arity(self)


    def base(self):
        """
        base(constellation_calcdist_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_calcdist_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_calcdist_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_calcdist_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_calcdist_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_calcdist_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_calcdist_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_calcdist_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_calcdist_sptr_soft_decision_maker(self, sample)

constellation_calcdist_sptr_swigregister = _ofdm_allocator_swig.constellation_calcdist_sptr_swigregister
constellation_calcdist_sptr_swigregister(constellation_calcdist_sptr)


constellation_calcdist_sptr.__repr__ = lambda self: "<constellation calcdist (m=%d)>" % (len(self.points()))
constellation_calcdist = constellation_calcdist.make;

class constellation_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_rect)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_rect)> self) -> constellation_rect_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_rect)> self, constellation_rect p) -> constellation_rect_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_rect_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_rect_sptr self) -> constellation_rect"""
        return _ofdm_allocator_swig.constellation_rect_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_rect_sptr
    __del__ = lambda self: None

    def make(self, constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors):
        """
        make(constellation_rect_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Make a rectangular constellation object.

        Params: (constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_make(self, constell, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_rect_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_rect_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_rect_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_arity(self)


    def base(self):
        """
        base(constellation_rect_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_rect_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_rect_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_rect_sptr_soft_decision_maker(self, sample)

constellation_rect_sptr_swigregister = _ofdm_allocator_swig.constellation_rect_sptr_swigregister
constellation_rect_sptr_swigregister(constellation_rect_sptr)


constellation_rect_sptr.__repr__ = lambda self: "<constellation rect (m=%d)>" % (len(self.points()))
constellation_rect = constellation_rect.make;

class constellation_expl_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_expl_rect)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_expl_rect)> self) -> constellation_expl_rect_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_expl_rect)> self, constellation_expl_rect p) -> constellation_expl_rect_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_expl_rect_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_expl_rect_sptr self) -> constellation_expl_rect"""
        return _ofdm_allocator_swig.constellation_expl_rect_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_expl_rect_sptr
    __del__ = lambda self: None

    def make(self, constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values):
        """
        make(constellation_expl_rect_sptr self, pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr



        Params: (constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_make(self, constellation, pre_diff_code, rotational_symmetry, real_sectors, imag_sectors, width_real_sectors, width_imag_sectors, sector_values)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_expl_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_expl_rect_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_expl_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_expl_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_expl_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_expl_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_expl_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_expl_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_expl_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_expl_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_expl_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_expl_rect_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_expl_rect_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_arity(self)


    def base(self):
        """
        base(constellation_expl_rect_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_expl_rect_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_expl_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_expl_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_expl_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_expl_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_expl_rect_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_expl_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_expl_rect_sptr_soft_decision_maker(self, sample)

constellation_expl_rect_sptr_swigregister = _ofdm_allocator_swig.constellation_expl_rect_sptr_swigregister
constellation_expl_rect_sptr_swigregister(constellation_expl_rect_sptr)


constellation_expl_rect_sptr.__repr__ = lambda self: "<constellation expl rect (m=%d)>" % (len(self.points()))
constellation_expl_rect = constellation_expl_rect.make;

class constellation_psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_psk)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_psk)> self) -> constellation_psk_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_psk)> self, constellation_psk p) -> constellation_psk_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_psk_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_psk_sptr self) -> constellation_psk"""
        return _ofdm_allocator_swig.constellation_psk_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_psk_sptr
    __del__ = lambda self: None

    def make(self, constell, pre_diff_code, n_sectors):
        """
        make(constellation_psk_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, unsigned int n_sectors) -> constellation_psk_sptr



        Params: (constell, pre_diff_code, n_sectors)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_make(self, constell, pre_diff_code, n_sectors)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_psk_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_psk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_psk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_arity(self)


    def base(self):
        """
        base(constellation_psk_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_psk_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_psk_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_psk_sptr_soft_decision_maker(self, sample)

constellation_psk_sptr_swigregister = _ofdm_allocator_swig.constellation_psk_sptr_swigregister
constellation_psk_sptr_swigregister(constellation_psk_sptr)


constellation_psk_sptr.__repr__ = lambda self: "<constellation PSK (m=%d)>" % (len(self.points()))
constellation_psk = constellation_psk.make;

class constellation_bpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_bpsk)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_bpsk)> self) -> constellation_bpsk_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_bpsk)> self, constellation_bpsk p) -> constellation_bpsk_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_bpsk_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_bpsk_sptr self) -> constellation_bpsk"""
        return _ofdm_allocator_swig.constellation_bpsk_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_bpsk_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_bpsk_sptr self) -> constellation_bpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_bpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_bpsk_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_bpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_bpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_bpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_bpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_bpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_bpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_bpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_bpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_bpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_bpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_bpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_arity(self)


    def base(self):
        """
        base(constellation_bpsk_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_bpsk_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_bpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_bpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_bpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_bpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_bpsk_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_bpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_bpsk_sptr_soft_decision_maker(self, sample)

constellation_bpsk_sptr_swigregister = _ofdm_allocator_swig.constellation_bpsk_sptr_swigregister
constellation_bpsk_sptr_swigregister(constellation_bpsk_sptr)


constellation_bpsk_sptr.__repr__ = lambda self: "<constellation BPSK>"
constellation_bpsk = constellation_bpsk.make;

class constellation_qpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_qpsk)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_qpsk)> self) -> constellation_qpsk_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_qpsk)> self, constellation_qpsk p) -> constellation_qpsk_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_qpsk_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_qpsk_sptr self) -> constellation_qpsk"""
        return _ofdm_allocator_swig.constellation_qpsk_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_qpsk_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_qpsk_sptr self) -> constellation_qpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_qpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_qpsk_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_qpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_qpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_qpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_qpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_qpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_qpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_qpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_qpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_qpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_qpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_qpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_arity(self)


    def base(self):
        """
        base(constellation_qpsk_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_qpsk_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_qpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_qpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_qpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_qpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_qpsk_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_qpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_qpsk_sptr_soft_decision_maker(self, sample)

constellation_qpsk_sptr_swigregister = _ofdm_allocator_swig.constellation_qpsk_sptr_swigregister
constellation_qpsk_sptr_swigregister(constellation_qpsk_sptr)


constellation_qpsk_sptr.__repr__ = lambda self: "<constellation QPSK>"
constellation_qpsk = constellation_qpsk.make;

class constellation_dqpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_dqpsk)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_dqpsk)> self) -> constellation_dqpsk_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_dqpsk)> self, constellation_dqpsk p) -> constellation_dqpsk_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_dqpsk_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_dqpsk_sptr self) -> constellation_dqpsk"""
        return _ofdm_allocator_swig.constellation_dqpsk_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_dqpsk_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_dqpsk_sptr self) -> constellation_dqpsk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_dqpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_dqpsk_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_dqpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_dqpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_dqpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_dqpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_dqpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_dqpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_dqpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_dqpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_dqpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_dqpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_dqpsk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_arity(self)


    def base(self):
        """
        base(constellation_dqpsk_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_dqpsk_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_dqpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_dqpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_dqpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_dqpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_dqpsk_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_dqpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_dqpsk_sptr_soft_decision_maker(self, sample)

constellation_dqpsk_sptr_swigregister = _ofdm_allocator_swig.constellation_dqpsk_sptr_swigregister
constellation_dqpsk_sptr_swigregister(constellation_dqpsk_sptr)


constellation_dqpsk_sptr.__repr__ = lambda self: "<constellation DQPSK>"
constellation_dqpsk = constellation_dqpsk.make;

class constellation_8psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk)> self) -> constellation_8psk_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk)> self, constellation_8psk p) -> constellation_8psk_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_8psk_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_8psk_sptr self) -> constellation_8psk"""
        return _ofdm_allocator_swig.constellation_8psk_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_8psk_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_8psk_sptr self) -> constellation_8psk_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_8psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_8psk_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_8psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_8psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_8psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_8psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_8psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_8psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_8psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_8psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_8psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_8psk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_8psk_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_arity(self)


    def base(self):
        """
        base(constellation_8psk_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_8psk_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_8psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_8psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_8psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_8psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_8psk_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_8psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_sptr_soft_decision_maker(self, sample)

constellation_8psk_sptr_swigregister = _ofdm_allocator_swig.constellation_8psk_sptr_swigregister
constellation_8psk_sptr_swigregister(constellation_8psk_sptr)


constellation_8psk_sptr.__repr__ = lambda self: "<constellation 8PSK>"
constellation_8psk = constellation_8psk.make;

class constellation_8psk_natural_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk_natural)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk_natural)> self) -> constellation_8psk_natural_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_8psk_natural)> self, constellation_8psk_natural p) -> constellation_8psk_natural_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_8psk_natural_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_8psk_natural_sptr self) -> constellation_8psk_natural"""
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_8psk_natural_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_8psk_natural_sptr self) -> constellation_8psk_natural_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_8psk_natural_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_8psk_natural_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_8psk_natural_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_8psk_natural_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_8psk_natural_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_8psk_natural_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_8psk_natural_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_8psk_natural_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_8psk_natural_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_8psk_natural_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_8psk_natural_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_8psk_natural_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_8psk_natural_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_8psk_natural_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_8psk_natural_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_8psk_natural_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_8psk_natural_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_8psk_natural_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_arity(self)


    def base(self):
        """
        base(constellation_8psk_natural_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_8psk_natural_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_8psk_natural_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_8psk_natural_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_8psk_natural_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_8psk_natural_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_8psk_natural_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_8psk_natural_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_8psk_natural_sptr_soft_decision_maker(self, sample)

constellation_8psk_natural_sptr_swigregister = _ofdm_allocator_swig.constellation_8psk_natural_sptr_swigregister
constellation_8psk_natural_sptr_swigregister(constellation_8psk_natural_sptr)


constellation_8psk_natural_sptr.__repr__ = lambda self: "<constellation 8PSK_natural>"
constellation_8psk_natural = constellation_8psk_natural.make;

class constellation_16qam_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_16qam)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_16qam)> self) -> constellation_16qam_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_16qam)> self, constellation_16qam p) -> constellation_16qam_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_16qam_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_16qam_sptr self) -> constellation_16qam"""
        return _ofdm_allocator_swig.constellation_16qam_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_16qam_sptr
    __del__ = lambda self: None

    def make(self):
        """
        make(constellation_16qam_sptr self) -> constellation_16qam_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_make(self)


    def map_to_points(self, value, points):
        """
        map_to_points(constellation_16qam_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.

        Params: (value, points)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_map_to_points(self, value, points)


    def map_to_points_v(self, value):
        """
        map_to_points_v(constellation_16qam_sptr self, unsigned int value) -> pmt_vector_cfloat



        Params: (value)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_map_to_points_v(self, value)


    def decision_maker(self, sample):
        """
        decision_maker(constellation_16qam_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_decision_maker(self, sample)


    def decision_maker_v(self, sample):
        """
        decision_maker_v(constellation_16qam_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_decision_maker_v(self, sample)


    def decision_maker_pe(self, sample, phase_error):
        """
        decision_maker_pe(constellation_16qam_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.

        Params: (sample, phase_error)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_decision_maker_pe(self, sample, phase_error)


    def calc_metric(self, sample, metric, type):
        """
        calc_metric(constellation_16qam_sptr self, gr_complex const * sample, float * metric, gr::ofdm_allocator::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.

        Params: (sample, metric, type)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_calc_metric(self, sample, metric, type)


    def calc_euclidean_metric(self, sample, metric):
        """
        calc_euclidean_metric(constellation_16qam_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_calc_euclidean_metric(self, sample, metric)


    def calc_hard_symbol_metric(self, sample, metric):
        """
        calc_hard_symbol_metric(constellation_16qam_sptr self, gr_complex const * sample, float * metric)



        Params: (sample, metric)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_calc_hard_symbol_metric(self, sample, metric)


    def points(self):
        """
        points(constellation_16qam_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_points(self)


    def s_points(self):
        """
        s_points(constellation_16qam_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_s_points(self)


    def v_points(self):
        """
        v_points(constellation_16qam_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_v_points(self)


    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_16qam_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_apply_pre_diff_code(self)


    def set_pre_diff_code(self, a):
        """
        set_pre_diff_code(constellation_16qam_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)

        Params: (a)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_set_pre_diff_code(self, a)


    def pre_diff_code(self):
        """
        pre_diff_code(constellation_16qam_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_pre_diff_code(self)


    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_16qam_sptr self) -> unsigned int

        Returns the order of rotational symmetry.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_rotational_symmetry(self)


    def dimensionality(self):
        """
        dimensionality(constellation_16qam_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_dimensionality(self)


    def bits_per_symbol(self):
        """
        bits_per_symbol(constellation_16qam_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_bits_per_symbol(self)


    def arity(self):
        """
        arity(constellation_16qam_sptr self) -> unsigned int



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_arity(self)


    def base(self):
        """
        base(constellation_16qam_sptr self) -> constellation_alix_sptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_base(self)


    def as_pmt(self):
        """
        as_pmt(constellation_16qam_sptr self) -> swig_int_ptr



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_as_pmt(self)


    def gen_soft_dec_lut(self, precision, npwr=1.0):
        """
        gen_soft_dec_lut(constellation_16qam_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.

        Params: (precision, npwr)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_gen_soft_dec_lut(self, precision, npwr)


    def calc_soft_dec(self, sample, npwr=1.0):
        """
        calc_soft_dec(constellation_16qam_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.

        Params: (sample, npwr)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_calc_soft_dec(self, sample, npwr)


    def set_soft_dec_lut(self, soft_dec_lut, precision):
        """
        set_soft_dec_lut(constellation_16qam_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.

        Params: (soft_dec_lut, precision)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_set_soft_dec_lut(self, soft_dec_lut, precision)


    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_16qam_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_has_soft_dec_lut(self)


    def soft_dec_lut(self):
        """
        soft_dec_lut(constellation_16qam_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >



        Params: (NONE)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_soft_dec_lut(self)


    def soft_decision_maker(self, sample):
        """
        soft_decision_maker(constellation_16qam_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.

        Params: (sample)
        """
        return _ofdm_allocator_swig.constellation_16qam_sptr_soft_decision_maker(self, sample)

constellation_16qam_sptr_swigregister = _ofdm_allocator_swig.constellation_16qam_sptr_swigregister
constellation_16qam_sptr_swigregister(constellation_16qam_sptr)


constellation_16qam_sptr.__repr__ = lambda self: "<constellation 16qam>"
constellation_16qam = constellation_16qam.make;

class constellation_decoder_alix(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(constellation):
        """
        make(constellation_alix_sptr constellation) -> constellation_decoder_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::constellation_decoder_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::constellation_decoder_alix's constructor is in a private implementation class. ofdm_allocator::constellation_decoder_alix::make is the public interface for creating new instances.

        Params: (constellation)
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_make(constellation)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_decoder_alix
    __del__ = lambda self: None
constellation_decoder_alix_swigregister = _ofdm_allocator_swig.constellation_decoder_alix_swigregister
constellation_decoder_alix_swigregister(constellation_decoder_alix)

def constellation_decoder_alix_make(constellation):
    """
    constellation_decoder_alix_make(constellation_alix_sptr constellation) -> constellation_decoder_alix_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::constellation_decoder_alix.

    To avoid accidental use of raw pointers, ofdm_allocator::constellation_decoder_alix's constructor is in a private implementation class. ofdm_allocator::constellation_decoder_alix::make is the public interface for creating new instances.

    Params: (constellation)
    """
    return _ofdm_allocator_swig.constellation_decoder_alix_make(constellation)

class constellation_decoder_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::constellation_decoder_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_decoder_alix)> self) -> constellation_decoder_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::constellation_decoder_alix)> self, constellation_decoder_alix p) -> constellation_decoder_alix_sptr
        """
        this = _ofdm_allocator_swig.new_constellation_decoder_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(constellation_decoder_alix_sptr self) -> constellation_decoder_alix"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_constellation_decoder_alix_sptr
    __del__ = lambda self: None

    def make(self, constellation):
        """
        make(constellation_decoder_alix_sptr self, constellation_alix_sptr constellation) -> constellation_decoder_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::constellation_decoder_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::constellation_decoder_alix's constructor is in a private implementation class. ofdm_allocator::constellation_decoder_alix::make is the public interface for creating new instances.

        Params: (constellation)
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_make(self, constellation)


    def history(self):
        """history(constellation_decoder_alix_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(constellation_decoder_alix_sptr self, int which, int delay)
        declare_sample_delay(constellation_decoder_alix_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(constellation_decoder_alix_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(constellation_decoder_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(constellation_decoder_alix_sptr self) -> double"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_relative_rate(self)


    def start(self):
        """start(constellation_decoder_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_start(self)


    def stop(self):
        """stop(constellation_decoder_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(constellation_decoder_alix_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(constellation_decoder_alix_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(constellation_decoder_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(constellation_decoder_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(constellation_decoder_alix_sptr self)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(constellation_decoder_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(constellation_decoder_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(constellation_decoder_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(constellation_decoder_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(constellation_decoder_alix_sptr self, long max_output_buffer)
        set_max_output_buffer(constellation_decoder_alix_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(constellation_decoder_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(constellation_decoder_alix_sptr self, long min_output_buffer)
        set_min_output_buffer(constellation_decoder_alix_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(constellation_decoder_alix_sptr self, int which) -> float
        pc_input_buffers_full(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(constellation_decoder_alix_sptr self, int which) -> float
        pc_input_buffers_full_avg(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(constellation_decoder_alix_sptr self, int which) -> float
        pc_input_buffers_full_var(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(constellation_decoder_alix_sptr self, int which) -> float
        pc_output_buffers_full(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(constellation_decoder_alix_sptr self, int which) -> float
        pc_output_buffers_full_avg(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(constellation_decoder_alix_sptr self, int which) -> float
        pc_output_buffers_full_var(constellation_decoder_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(constellation_decoder_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(constellation_decoder_alix_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(constellation_decoder_alix_sptr self)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(constellation_decoder_alix_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(constellation_decoder_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(constellation_decoder_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(constellation_decoder_alix_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(constellation_decoder_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_name(self)


    def symbol_name(self):
        """symbol_name(constellation_decoder_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(constellation_decoder_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(constellation_decoder_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(constellation_decoder_alix_sptr self) -> long"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(constellation_decoder_alix_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(constellation_decoder_alix_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(constellation_decoder_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(constellation_decoder_alix_sptr self, std::string name)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(constellation_decoder_alix_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(constellation_decoder_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(constellation_decoder_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(constellation_decoder_alix_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.constellation_decoder_alix_sptr_message_subscribers(self, which_port)

constellation_decoder_alix_sptr_swigregister = _ofdm_allocator_swig.constellation_decoder_alix_sptr_swigregister
constellation_decoder_alix_sptr_swigregister(constellation_decoder_alix_sptr)


constellation_decoder_alix_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
constellation_decoder_alix = constellation_decoder_alix.make;

class packet_header_parser_alix(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(*args):
        """
        make(packet_header_default_alix_sptr header_formatter, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr
        make(long header_len, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::packet_header_parser_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::packet_header_parser_alix's constructor is in a private implementation class. ofdm_allocator::packet_header_parser_alix::make is the public interface for creating new instances.

        Params: (header_formatter, len_tag_key, num_tag_key)
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_parser_alix
    __del__ = lambda self: None
packet_header_parser_alix_swigregister = _ofdm_allocator_swig.packet_header_parser_alix_swigregister
packet_header_parser_alix_swigregister(packet_header_parser_alix)

def packet_header_parser_alix_make(*args):
    """
    make(packet_header_default_alix_sptr header_formatter, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr
    packet_header_parser_alix_make(long header_len, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::packet_header_parser_alix.

    To avoid accidental use of raw pointers, ofdm_allocator::packet_header_parser_alix's constructor is in a private implementation class. ofdm_allocator::packet_header_parser_alix::make is the public interface for creating new instances.

    Params: (header_formatter, len_tag_key, num_tag_key)
    """
    return _ofdm_allocator_swig.packet_header_parser_alix_make(*args)

class packet_header_parser_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::packet_header_parser_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_parser_alix)> self) -> packet_header_parser_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::packet_header_parser_alix)> self, packet_header_parser_alix p) -> packet_header_parser_alix_sptr
        """
        this = _ofdm_allocator_swig.new_packet_header_parser_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(packet_header_parser_alix_sptr self) -> packet_header_parser_alix"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_packet_header_parser_alix_sptr
    __del__ = lambda self: None

    def make(self, *args):
        """
        make(packet_header_parser_alix_sptr self, packet_header_default_alix_sptr header_formatter, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr
        make(packet_header_parser_alix_sptr self, long header_len, std::string const & len_tag_key, std::string const & num_tag_key) -> packet_header_parser_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::packet_header_parser_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::packet_header_parser_alix's constructor is in a private implementation class. ofdm_allocator::packet_header_parser_alix::make is the public interface for creating new instances.

        Params: (header_formatter, len_tag_key, num_tag_key)
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_make(self, *args)


    def history(self):
        """history(packet_header_parser_alix_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(packet_header_parser_alix_sptr self, int which, int delay)
        declare_sample_delay(packet_header_parser_alix_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(packet_header_parser_alix_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(packet_header_parser_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(packet_header_parser_alix_sptr self) -> double"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_relative_rate(self)


    def start(self):
        """start(packet_header_parser_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_start(self)


    def stop(self):
        """stop(packet_header_parser_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(packet_header_parser_alix_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(packet_header_parser_alix_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(packet_header_parser_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(packet_header_parser_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(packet_header_parser_alix_sptr self)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(packet_header_parser_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(packet_header_parser_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(packet_header_parser_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(packet_header_parser_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(packet_header_parser_alix_sptr self, long max_output_buffer)
        set_max_output_buffer(packet_header_parser_alix_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(packet_header_parser_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(packet_header_parser_alix_sptr self, long min_output_buffer)
        set_min_output_buffer(packet_header_parser_alix_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(packet_header_parser_alix_sptr self, int which) -> float
        pc_input_buffers_full(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(packet_header_parser_alix_sptr self, int which) -> float
        pc_input_buffers_full_avg(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(packet_header_parser_alix_sptr self, int which) -> float
        pc_input_buffers_full_var(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(packet_header_parser_alix_sptr self, int which) -> float
        pc_output_buffers_full(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(packet_header_parser_alix_sptr self, int which) -> float
        pc_output_buffers_full_avg(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(packet_header_parser_alix_sptr self, int which) -> float
        pc_output_buffers_full_var(packet_header_parser_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(packet_header_parser_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(packet_header_parser_alix_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(packet_header_parser_alix_sptr self)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(packet_header_parser_alix_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(packet_header_parser_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(packet_header_parser_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(packet_header_parser_alix_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(packet_header_parser_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_name(self)


    def symbol_name(self):
        """symbol_name(packet_header_parser_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(packet_header_parser_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(packet_header_parser_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(packet_header_parser_alix_sptr self) -> long"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(packet_header_parser_alix_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(packet_header_parser_alix_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(packet_header_parser_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(packet_header_parser_alix_sptr self, std::string name)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(packet_header_parser_alix_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(packet_header_parser_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(packet_header_parser_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(packet_header_parser_alix_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.packet_header_parser_alix_sptr_message_subscribers(self, which_port)

packet_header_parser_alix_sptr_swigregister = _ofdm_allocator_swig.packet_header_parser_alix_sptr_swigregister
packet_header_parser_alix_sptr_swigregister(packet_header_parser_alix_sptr)


packet_header_parser_alix_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
packet_header_parser_alix = packet_header_parser_alix.make;

class per_measure(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(sizeof_stream_item, window):
        """
        make(size_t sizeof_stream_item, int window) -> per_measure_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::per_measure.

        To avoid accidental use of raw pointers, ofdm_allocator::per_measure's constructor is in a private implementation class. ofdm_allocator::per_measure::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.per_measure_make(sizeof_stream_item, window)

    make = staticmethod(make)

    def current_tags(self):
        """
        current_tags(per_measure self) -> tags_vector_t

        Returns a vector of tag_t items as of the last call to work.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_current_tags(self)


    def num_tags(self):
        """
        num_tags(per_measure self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_num_tags(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_per_measure
    __del__ = lambda self: None
per_measure_swigregister = _ofdm_allocator_swig.per_measure_swigregister
per_measure_swigregister(per_measure)

def per_measure_make(sizeof_stream_item, window):
    """
    per_measure_make(size_t sizeof_stream_item, int window) -> per_measure_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::per_measure.

    To avoid accidental use of raw pointers, ofdm_allocator::per_measure's constructor is in a private implementation class. ofdm_allocator::per_measure::make is the public interface for creating new instances.

    Params: (sizeof_stream_item, window)
    """
    return _ofdm_allocator_swig.per_measure_make(sizeof_stream_item, window)

class per_measure_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::per_measure)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::per_measure)> self) -> per_measure_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::per_measure)> self, per_measure p) -> per_measure_sptr
        """
        this = _ofdm_allocator_swig.new_per_measure_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(per_measure_sptr self) -> per_measure"""
        return _ofdm_allocator_swig.per_measure_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_per_measure_sptr
    __del__ = lambda self: None

    def make(self, sizeof_stream_item, window):
        """
        make(per_measure_sptr self, size_t sizeof_stream_item, int window) -> per_measure_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::per_measure.

        To avoid accidental use of raw pointers, ofdm_allocator::per_measure's constructor is in a private implementation class. ofdm_allocator::per_measure::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.per_measure_sptr_make(self, sizeof_stream_item, window)


    def current_tags(self):
        """
        current_tags(per_measure_sptr self) -> tags_vector_t

        Returns a vector of tag_t items as of the last call to work.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_sptr_current_tags(self)


    def num_tags(self):
        """
        num_tags(per_measure_sptr self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_sptr_num_tags(self)


    def history(self):
        """history(per_measure_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.per_measure_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(per_measure_sptr self, int which, int delay)
        declare_sample_delay(per_measure_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.per_measure_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(per_measure_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.per_measure_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(per_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(per_measure_sptr self) -> double"""
        return _ofdm_allocator_swig.per_measure_sptr_relative_rate(self)


    def start(self):
        """start(per_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_sptr_start(self)


    def stop(self):
        """stop(per_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(per_measure_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.per_measure_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(per_measure_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.per_measure_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(per_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(per_measure_sptr self, int m)"""
        return _ofdm_allocator_swig.per_measure_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(per_measure_sptr self)"""
        return _ofdm_allocator_swig.per_measure_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(per_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(per_measure_sptr self, int m)"""
        return _ofdm_allocator_swig.per_measure_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(per_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(per_measure_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.per_measure_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(per_measure_sptr self, long max_output_buffer)
        set_max_output_buffer(per_measure_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.per_measure_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(per_measure_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.per_measure_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(per_measure_sptr self, long min_output_buffer)
        set_min_output_buffer(per_measure_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.per_measure_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(per_measure_sptr self, int which) -> float
        pc_input_buffers_full(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(per_measure_sptr self, int which) -> float
        pc_input_buffers_full_avg(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(per_measure_sptr self, int which) -> float
        pc_input_buffers_full_var(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(per_measure_sptr self, int which) -> float
        pc_output_buffers_full(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(per_measure_sptr self, int which) -> float
        pc_output_buffers_full_avg(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(per_measure_sptr self, int which) -> float
        pc_output_buffers_full_var(per_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(per_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(per_measure_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.per_measure_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(per_measure_sptr self)"""
        return _ofdm_allocator_swig.per_measure_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(per_measure_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.per_measure_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(per_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(per_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(per_measure_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.per_measure_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(per_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_sptr_name(self)


    def symbol_name(self):
        """symbol_name(per_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(per_measure_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.per_measure_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(per_measure_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.per_measure_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(per_measure_sptr self) -> long"""
        return _ofdm_allocator_swig.per_measure_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(per_measure_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.per_measure_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(per_measure_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.per_measure_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(per_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(per_measure_sptr self, std::string name)"""
        return _ofdm_allocator_swig.per_measure_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(per_measure_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.per_measure_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(per_measure_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(per_measure_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(per_measure_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_sptr_message_subscribers(self, which_port)

per_measure_sptr_swigregister = _ofdm_allocator_swig.per_measure_sptr_swigregister
per_measure_sptr_swigregister(per_measure_sptr)


per_measure_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
per_measure = per_measure.make;

class pkt_err_measure(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(sizeof_stream_item, window):
        """
        make(size_t sizeof_stream_item, int window) -> pkt_err_measure_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::pkt_err_measure.

        To avoid accidental use of raw pointers, ofdm_allocator::pkt_err_measure's constructor is in a private implementation class. ofdm_allocator::pkt_err_measure::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.pkt_err_measure_make(sizeof_stream_item, window)

    make = staticmethod(make)

    def current_tags(self):
        """
        current_tags(pkt_err_measure self) -> tags_vector_t



        Params: (NONE)
        """
        return _ofdm_allocator_swig.pkt_err_measure_current_tags(self)


    def num_tags(self):
        """
        num_tags(pkt_err_measure self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.pkt_err_measure_num_tags(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_pkt_err_measure
    __del__ = lambda self: None
pkt_err_measure_swigregister = _ofdm_allocator_swig.pkt_err_measure_swigregister
pkt_err_measure_swigregister(pkt_err_measure)

def pkt_err_measure_make(sizeof_stream_item, window):
    """
    pkt_err_measure_make(size_t sizeof_stream_item, int window) -> pkt_err_measure_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::pkt_err_measure.

    To avoid accidental use of raw pointers, ofdm_allocator::pkt_err_measure's constructor is in a private implementation class. ofdm_allocator::pkt_err_measure::make is the public interface for creating new instances.

    Params: (sizeof_stream_item, window)
    """
    return _ofdm_allocator_swig.pkt_err_measure_make(sizeof_stream_item, window)

class pkt_err_measure_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::pkt_err_measure)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::pkt_err_measure)> self) -> pkt_err_measure_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::pkt_err_measure)> self, pkt_err_measure p) -> pkt_err_measure_sptr
        """
        this = _ofdm_allocator_swig.new_pkt_err_measure_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(pkt_err_measure_sptr self) -> pkt_err_measure"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_pkt_err_measure_sptr
    __del__ = lambda self: None

    def make(self, sizeof_stream_item, window):
        """
        make(pkt_err_measure_sptr self, size_t sizeof_stream_item, int window) -> pkt_err_measure_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::pkt_err_measure.

        To avoid accidental use of raw pointers, ofdm_allocator::pkt_err_measure's constructor is in a private implementation class. ofdm_allocator::pkt_err_measure::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_make(self, sizeof_stream_item, window)


    def current_tags(self):
        """
        current_tags(pkt_err_measure_sptr self) -> tags_vector_t



        Params: (NONE)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_current_tags(self)


    def num_tags(self):
        """
        num_tags(pkt_err_measure_sptr self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_num_tags(self)


    def history(self):
        """history(pkt_err_measure_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pkt_err_measure_sptr self, int which, int delay)
        declare_sample_delay(pkt_err_measure_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(pkt_err_measure_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(pkt_err_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(pkt_err_measure_sptr self) -> double"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_relative_rate(self)


    def start(self):
        """start(pkt_err_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_start(self)


    def stop(self):
        """stop(pkt_err_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(pkt_err_measure_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(pkt_err_measure_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(pkt_err_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(pkt_err_measure_sptr self, int m)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pkt_err_measure_sptr self)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pkt_err_measure_sptr self) -> bool"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(pkt_err_measure_sptr self, int m)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(pkt_err_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(pkt_err_measure_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pkt_err_measure_sptr self, long max_output_buffer)
        set_max_output_buffer(pkt_err_measure_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(pkt_err_measure_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pkt_err_measure_sptr self, long min_output_buffer)
        set_min_output_buffer(pkt_err_measure_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pkt_err_measure_sptr self, int which) -> float
        pc_input_buffers_full(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pkt_err_measure_sptr self, int which) -> float
        pc_input_buffers_full_avg(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pkt_err_measure_sptr self, int which) -> float
        pc_input_buffers_full_var(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pkt_err_measure_sptr self, int which) -> float
        pc_output_buffers_full(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pkt_err_measure_sptr self, int which) -> float
        pc_output_buffers_full_avg(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pkt_err_measure_sptr self, int which) -> float
        pc_output_buffers_full_var(pkt_err_measure_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(pkt_err_measure_sptr self) -> float"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(pkt_err_measure_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(pkt_err_measure_sptr self)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(pkt_err_measure_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(pkt_err_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(pkt_err_measure_sptr self) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(pkt_err_measure_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(pkt_err_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_name(self)


    def symbol_name(self):
        """symbol_name(pkt_err_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(pkt_err_measure_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(pkt_err_measure_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(pkt_err_measure_sptr self) -> long"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(pkt_err_measure_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(pkt_err_measure_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(pkt_err_measure_sptr self) -> std::string"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(pkt_err_measure_sptr self, std::string name)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(pkt_err_measure_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(pkt_err_measure_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(pkt_err_measure_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(pkt_err_measure_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.pkt_err_measure_sptr_message_subscribers(self, which_port)

pkt_err_measure_sptr_swigregister = _ofdm_allocator_swig.pkt_err_measure_sptr_swigregister
pkt_err_measure_sptr_swigregister(pkt_err_measure_sptr)


pkt_err_measure_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pkt_err_measure = pkt_err_measure.make;

class per_measure_decimator(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def make(sizeof_stream_item, window):
        """
        make(size_t sizeof_stream_item, int window) -> per_measure_decimator_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::per_measure_decimator.

        To avoid accidental use of raw pointers, ofdm_allocator::per_measure_decimator's constructor is in a private implementation class. ofdm_allocator::per_measure_decimator::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.per_measure_decimator_make(sizeof_stream_item, window)

    make = staticmethod(make)

    def current_tags(self):
        """
        current_tags(per_measure_decimator self) -> tags_vector_t



        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_decimator_current_tags(self)


    def num_tags(self):
        """
        num_tags(per_measure_decimator self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_decimator_num_tags(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_per_measure_decimator
    __del__ = lambda self: None
per_measure_decimator_swigregister = _ofdm_allocator_swig.per_measure_decimator_swigregister
per_measure_decimator_swigregister(per_measure_decimator)

def per_measure_decimator_make(sizeof_stream_item, window):
    """
    per_measure_decimator_make(size_t sizeof_stream_item, int window) -> per_measure_decimator_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::per_measure_decimator.

    To avoid accidental use of raw pointers, ofdm_allocator::per_measure_decimator's constructor is in a private implementation class. ofdm_allocator::per_measure_decimator::make is the public interface for creating new instances.

    Params: (sizeof_stream_item, window)
    """
    return _ofdm_allocator_swig.per_measure_decimator_make(sizeof_stream_item, window)

class per_measure_decimator_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::per_measure_decimator)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::per_measure_decimator)> self) -> per_measure_decimator_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::per_measure_decimator)> self, per_measure_decimator p) -> per_measure_decimator_sptr
        """
        this = _ofdm_allocator_swig.new_per_measure_decimator_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(per_measure_decimator_sptr self) -> per_measure_decimator"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_per_measure_decimator_sptr
    __del__ = lambda self: None

    def make(self, sizeof_stream_item, window):
        """
        make(per_measure_decimator_sptr self, size_t sizeof_stream_item, int window) -> per_measure_decimator_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::per_measure_decimator.

        To avoid accidental use of raw pointers, ofdm_allocator::per_measure_decimator's constructor is in a private implementation class. ofdm_allocator::per_measure_decimator::make is the public interface for creating new instances.

        Params: (sizeof_stream_item, window)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_make(self, sizeof_stream_item, window)


    def current_tags(self):
        """
        current_tags(per_measure_decimator_sptr self) -> tags_vector_t



        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_current_tags(self)


    def num_tags(self):
        """
        num_tags(per_measure_decimator_sptr self) -> int

        Return the total number of tags in the tag queue.

        Params: (NONE)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_num_tags(self)


    def history(self):
        """history(per_measure_decimator_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(per_measure_decimator_sptr self, int which, int delay)
        declare_sample_delay(per_measure_decimator_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(per_measure_decimator_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(per_measure_decimator_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(per_measure_decimator_sptr self) -> double"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_relative_rate(self)


    def start(self):
        """start(per_measure_decimator_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_start(self)


    def stop(self):
        """stop(per_measure_decimator_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(per_measure_decimator_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(per_measure_decimator_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(per_measure_decimator_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(per_measure_decimator_sptr self, int m)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(per_measure_decimator_sptr self)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(per_measure_decimator_sptr self) -> bool"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(per_measure_decimator_sptr self, int m)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(per_measure_decimator_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(per_measure_decimator_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(per_measure_decimator_sptr self, long max_output_buffer)
        set_max_output_buffer(per_measure_decimator_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(per_measure_decimator_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(per_measure_decimator_sptr self, long min_output_buffer)
        set_min_output_buffer(per_measure_decimator_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(per_measure_decimator_sptr self, int which) -> float
        pc_input_buffers_full(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(per_measure_decimator_sptr self, int which) -> float
        pc_input_buffers_full_avg(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(per_measure_decimator_sptr self, int which) -> float
        pc_input_buffers_full_var(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(per_measure_decimator_sptr self, int which) -> float
        pc_output_buffers_full(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(per_measure_decimator_sptr self, int which) -> float
        pc_output_buffers_full_avg(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(per_measure_decimator_sptr self, int which) -> float
        pc_output_buffers_full_var(per_measure_decimator_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(per_measure_decimator_sptr self) -> float"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(per_measure_decimator_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(per_measure_decimator_sptr self)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(per_measure_decimator_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(per_measure_decimator_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(per_measure_decimator_sptr self) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(per_measure_decimator_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(per_measure_decimator_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_name(self)


    def symbol_name(self):
        """symbol_name(per_measure_decimator_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(per_measure_decimator_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(per_measure_decimator_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(per_measure_decimator_sptr self) -> long"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(per_measure_decimator_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(per_measure_decimator_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(per_measure_decimator_sptr self) -> std::string"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(per_measure_decimator_sptr self, std::string name)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(per_measure_decimator_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(per_measure_decimator_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(per_measure_decimator_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(per_measure_decimator_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.per_measure_decimator_sptr_message_subscribers(self, which_port)

per_measure_decimator_sptr_swigregister = _ofdm_allocator_swig.per_measure_decimator_sptr_swigregister
per_measure_decimator_sptr_swigregister(per_measure_decimator_sptr)


per_measure_decimator_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
per_measure_decimator = per_measure_decimator.make;

class crc_alix(object):
    """<+description of block+>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def make(*args, **kwargs):
        """
        make(bool check=False, std::string const & lengthtagname, bool packed=True) -> crc_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::crc_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::crc_alix's constructor is in a private implementation class. ofdm_allocator::crc_alix::make is the public interface for creating new instances.

        Params: (check, lengthtagname, packed)
        """
        return _ofdm_allocator_swig.crc_alix_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _ofdm_allocator_swig.delete_crc_alix
    __del__ = lambda self: None
crc_alix_swigregister = _ofdm_allocator_swig.crc_alix_swigregister
crc_alix_swigregister(crc_alix)

def crc_alix_make(*args, **kwargs):
    """
    crc_alix_make(bool check=False, std::string const & lengthtagname, bool packed=True) -> crc_alix_sptr

    Return a shared_ptr to a new instance of ofdm_allocator::crc_alix.

    To avoid accidental use of raw pointers, ofdm_allocator::crc_alix's constructor is in a private implementation class. ofdm_allocator::crc_alix::make is the public interface for creating new instances.

    Params: (check, lengthtagname, packed)
    """
    return _ofdm_allocator_swig.crc_alix_make(*args, **kwargs)

class crc_alix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::ofdm_allocator::crc_alix)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(boost::shared_ptr<(gr::ofdm_allocator::crc_alix)> self) -> crc_alix_sptr
        __init__(boost::shared_ptr<(gr::ofdm_allocator::crc_alix)> self, crc_alix p) -> crc_alix_sptr
        """
        this = _ofdm_allocator_swig.new_crc_alix_sptr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        """__deref__(crc_alix_sptr self) -> crc_alix"""
        return _ofdm_allocator_swig.crc_alix_sptr___deref__(self)

    __swig_destroy__ = _ofdm_allocator_swig.delete_crc_alix_sptr
    __del__ = lambda self: None

    def make(self, *args, **kwargs):
        """
        make(crc_alix_sptr self, bool check=False, std::string const & lengthtagname, bool packed=True) -> crc_alix_sptr

        Return a shared_ptr to a new instance of ofdm_allocator::crc_alix.

        To avoid accidental use of raw pointers, ofdm_allocator::crc_alix's constructor is in a private implementation class. ofdm_allocator::crc_alix::make is the public interface for creating new instances.

        Params: (check, lengthtagname, packed)
        """
        return _ofdm_allocator_swig.crc_alix_sptr_make(self, *args, **kwargs)


    def history(self):
        """history(crc_alix_sptr self) -> unsigned int"""
        return _ofdm_allocator_swig.crc_alix_sptr_history(self)


    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(crc_alix_sptr self, int which, int delay)
        declare_sample_delay(crc_alix_sptr self, unsigned int delay)
        """
        return _ofdm_allocator_swig.crc_alix_sptr_declare_sample_delay(self, *args)


    def sample_delay(self, which):
        """sample_delay(crc_alix_sptr self, int which) -> unsigned int"""
        return _ofdm_allocator_swig.crc_alix_sptr_sample_delay(self, which)


    def output_multiple(self):
        """output_multiple(crc_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_output_multiple(self)


    def relative_rate(self):
        """relative_rate(crc_alix_sptr self) -> double"""
        return _ofdm_allocator_swig.crc_alix_sptr_relative_rate(self)


    def start(self):
        """start(crc_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.crc_alix_sptr_start(self)


    def stop(self):
        """stop(crc_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.crc_alix_sptr_stop(self)


    def nitems_read(self, which_input):
        """nitems_read(crc_alix_sptr self, unsigned int which_input) -> uint64_t"""
        return _ofdm_allocator_swig.crc_alix_sptr_nitems_read(self, which_input)


    def nitems_written(self, which_output):
        """nitems_written(crc_alix_sptr self, unsigned int which_output) -> uint64_t"""
        return _ofdm_allocator_swig.crc_alix_sptr_nitems_written(self, which_output)


    def max_noutput_items(self):
        """max_noutput_items(crc_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_max_noutput_items(self)


    def set_max_noutput_items(self, m):
        """set_max_noutput_items(crc_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.crc_alix_sptr_set_max_noutput_items(self, m)


    def unset_max_noutput_items(self):
        """unset_max_noutput_items(crc_alix_sptr self)"""
        return _ofdm_allocator_swig.crc_alix_sptr_unset_max_noutput_items(self)


    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(crc_alix_sptr self) -> bool"""
        return _ofdm_allocator_swig.crc_alix_sptr_is_set_max_noutput_items(self)


    def set_min_noutput_items(self, m):
        """set_min_noutput_items(crc_alix_sptr self, int m)"""
        return _ofdm_allocator_swig.crc_alix_sptr_set_min_noutput_items(self, m)


    def min_noutput_items(self):
        """min_noutput_items(crc_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_min_noutput_items(self)


    def max_output_buffer(self, i):
        """max_output_buffer(crc_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.crc_alix_sptr_max_output_buffer(self, i)


    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(crc_alix_sptr self, long max_output_buffer)
        set_max_output_buffer(crc_alix_sptr self, int port, long max_output_buffer)
        """
        return _ofdm_allocator_swig.crc_alix_sptr_set_max_output_buffer(self, *args)


    def min_output_buffer(self, i):
        """min_output_buffer(crc_alix_sptr self, int i) -> long"""
        return _ofdm_allocator_swig.crc_alix_sptr_min_output_buffer(self, i)


    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(crc_alix_sptr self, long min_output_buffer)
        set_min_output_buffer(crc_alix_sptr self, int port, long min_output_buffer)
        """
        return _ofdm_allocator_swig.crc_alix_sptr_set_min_output_buffer(self, *args)


    def pc_noutput_items(self):
        """pc_noutput_items(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_noutput_items(self)


    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_noutput_items_avg(self)


    def pc_noutput_items_var(self):
        """pc_noutput_items_var(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_noutput_items_var(self)


    def pc_nproduced(self):
        """pc_nproduced(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_nproduced(self)


    def pc_nproduced_avg(self):
        """pc_nproduced_avg(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_nproduced_avg(self)


    def pc_nproduced_var(self):
        """pc_nproduced_var(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_nproduced_var(self)


    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(crc_alix_sptr self, int which) -> float
        pc_input_buffers_full(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_input_buffers_full(self, *args)


    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(crc_alix_sptr self, int which) -> float
        pc_input_buffers_full_avg(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_input_buffers_full_avg(self, *args)


    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(crc_alix_sptr self, int which) -> float
        pc_input_buffers_full_var(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_input_buffers_full_var(self, *args)


    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(crc_alix_sptr self, int which) -> float
        pc_output_buffers_full(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_output_buffers_full(self, *args)


    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(crc_alix_sptr self, int which) -> float
        pc_output_buffers_full_avg(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_output_buffers_full_avg(self, *args)


    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(crc_alix_sptr self, int which) -> float
        pc_output_buffers_full_var(crc_alix_sptr self) -> pmt_vector_float
        """
        return _ofdm_allocator_swig.crc_alix_sptr_pc_output_buffers_full_var(self, *args)


    def pc_work_time(self):
        """pc_work_time(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_work_time(self)


    def pc_work_time_avg(self):
        """pc_work_time_avg(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_work_time_avg(self)


    def pc_work_time_var(self):
        """pc_work_time_var(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_work_time_var(self)


    def pc_work_time_total(self):
        """pc_work_time_total(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_work_time_total(self)


    def pc_throughput_avg(self):
        """pc_throughput_avg(crc_alix_sptr self) -> float"""
        return _ofdm_allocator_swig.crc_alix_sptr_pc_throughput_avg(self)


    def set_processor_affinity(self, mask):
        """set_processor_affinity(crc_alix_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _ofdm_allocator_swig.crc_alix_sptr_set_processor_affinity(self, mask)


    def unset_processor_affinity(self):
        """unset_processor_affinity(crc_alix_sptr self)"""
        return _ofdm_allocator_swig.crc_alix_sptr_unset_processor_affinity(self)


    def processor_affinity(self):
        """processor_affinity(crc_alix_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _ofdm_allocator_swig.crc_alix_sptr_processor_affinity(self)


    def active_thread_priority(self):
        """active_thread_priority(crc_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_active_thread_priority(self)


    def thread_priority(self):
        """thread_priority(crc_alix_sptr self) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_thread_priority(self)


    def set_thread_priority(self, priority):
        """set_thread_priority(crc_alix_sptr self, int priority) -> int"""
        return _ofdm_allocator_swig.crc_alix_sptr_set_thread_priority(self, priority)


    def name(self):
        """name(crc_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.crc_alix_sptr_name(self)


    def symbol_name(self):
        """symbol_name(crc_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.crc_alix_sptr_symbol_name(self)


    def input_signature(self):
        """input_signature(crc_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_input_signature(self)


    def output_signature(self):
        """output_signature(crc_alix_sptr self) -> io_signature_sptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_output_signature(self)


    def unique_id(self):
        """unique_id(crc_alix_sptr self) -> long"""
        return _ofdm_allocator_swig.crc_alix_sptr_unique_id(self)


    def to_basic_block(self):
        """to_basic_block(crc_alix_sptr self) -> basic_block_sptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_to_basic_block(self)


    def check_topology(self, ninputs, noutputs):
        """check_topology(crc_alix_sptr self, int ninputs, int noutputs) -> bool"""
        return _ofdm_allocator_swig.crc_alix_sptr_check_topology(self, ninputs, noutputs)


    def alias(self):
        """alias(crc_alix_sptr self) -> std::string"""
        return _ofdm_allocator_swig.crc_alix_sptr_alias(self)


    def set_block_alias(self, name):
        """set_block_alias(crc_alix_sptr self, std::string name)"""
        return _ofdm_allocator_swig.crc_alix_sptr_set_block_alias(self, name)


    def _post(self, which_port, msg):
        """_post(crc_alix_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _ofdm_allocator_swig.crc_alix_sptr__post(self, which_port, msg)


    def message_ports_in(self):
        """message_ports_in(crc_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_message_ports_in(self)


    def message_ports_out(self):
        """message_ports_out(crc_alix_sptr self) -> swig_int_ptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_message_ports_out(self)


    def message_subscribers(self, which_port):
        """message_subscribers(crc_alix_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _ofdm_allocator_swig.crc_alix_sptr_message_subscribers(self, which_port)

crc_alix_sptr_swigregister = _ofdm_allocator_swig.crc_alix_sptr_swigregister
crc_alix_sptr_swigregister(crc_alix_sptr)


crc_alix_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
crc_alix = crc_alix.make;



